<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reformer · EnergyModelsHydrogen</title><meta name="title" content="Reformer · EnergyModelsHydrogen"/><meta property="og:title" content="Reformer · EnergyModelsHydrogen"/><meta property="twitter:title" content="Reformer · EnergyModelsHydrogen"/><meta name="description" content="Documentation for EnergyModelsHydrogen."/><meta property="og:description" content="Documentation for EnergyModelsHydrogen."/><meta property="twitter:description" content="Documentation for EnergyModelsHydrogen."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">EnergyModelsHydrogen</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../manual/quick-start/">Quick Start</a></li><li><a class="tocitem" href="../../manual/simple-example/">Examples</a></li><li><a class="tocitem" href="../../manual/NEWS/">Release notes</a></li></ul></li><li><span class="tocitem">Nodes</span><ul><li><a class="tocitem" href="../electrolyzer/">Electrolyzer</a></li><li class="is-active"><a class="tocitem" href>Reformer</a><ul class="internal"><li><a class="tocitem" href="#nodes-ref-fields"><span>Introduced type and its field</span></a></li><li><a class="tocitem" href="#nodes-ref-math"><span>Mathematical description</span></a></li></ul></li><li><a class="tocitem" href="../h2_storage/">H₂ storage</a></li></ul></li><li><span class="tocitem">How to</span><ul><li><a class="tocitem" href="../../how-to/contribute/">Contribute to EnergyModelsHydrogen</a></li></ul></li><li><span class="tocitem">Auxiliary functions</span><ul><li><a class="tocitem" href="../../aux-fun/lin-reform/">Linear reformulation</a></li><li><a class="tocitem" href="../../aux-fun/pressure_calc/">Compression energy</a></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../../library/public/">Public</a></li><li><input class="collapse-toggle" id="menuitem-6-2" type="checkbox"/><label class="tocitem" for="menuitem-6-2"><span class="docs-label">Internals</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../library/internals/types-EMH/">Types</a></li><li><a class="tocitem" href="../../library/internals/methods-fields/">Methods - Accessing fields</a></li><li><a class="tocitem" href="../../library/internals/methods-EMH/">Methods - Internal</a></li><li><a class="tocitem" href="../../library/internals/methods-EMB/">Methods - <code>EnergyModelsBase</code></a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Nodes</a></li><li class="is-active"><a href>Reformer</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reformer</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/EnergyModelsX/EnergyModelsHydrogen.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/EnergyModelsX/EnergyModelsHydrogen.jl/blob/main/docs/src/nodes/reformer.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="nodes-ref"><a class="docs-heading-anchor" href="#nodes-ref">Reformer node</a><a id="nodes-ref-1"></a><a class="docs-heading-anchor-permalink" href="#nodes-ref" title="Permalink"></a></h1><p>Reformer plants are in general large chemical production facilities as they experience significant economies of scale. Utilizing standard modelling approaches would hence result in an overestimation of the flexibility and operating windows of the plants. They can be characterized by:</p><ol><li>a slow change in their operating point due to both heat and mass integration within the process,</li><li>a minimum operating point under which they cannot operate,</li><li>significant time requirements for both start-up and shutdown with corresponding costs due to integration of the processes, and</li><li>a minimum down time once turned off.</li></ol><p>In this respect, reformer plants should be represented with unit commitment constraints with 4 distinctive states, startup, online, shutdown, and offline.</p><h2 id="nodes-ref-fields"><a class="docs-heading-anchor" href="#nodes-ref-fields">Introduced type and its field</a><a id="nodes-ref-fields-1"></a><a class="docs-heading-anchor-permalink" href="#nodes-ref-fields" title="Permalink"></a></h2><p>Reformer are incorporated through a single composite type <a href="../../library/public/#EnergyModelsHydrogen.Reformer"><code>Reformer</code></a> although provisions are made to include other types. The following sections will provide you with an explanation of the individual fields of the type.</p><div class="admonition is-danger"><header class="admonition-header">Reformer with changing capacities</header><div class="admonition-body"><p>The unit commitment, minimum usage, and rate of change constraints are for the installed capacity. This implies that if you include changing capacities over the course of time or if you include investments, it is required to include a separate node for each investment period with a changing capacity.</p></div></div><h3 id="nodes-ref-fields-stand"><a class="docs-heading-anchor" href="#nodes-ref-fields-stand">Standard fields</a><a id="nodes-ref-fields-stand-1"></a><a class="docs-heading-anchor-permalink" href="#nodes-ref-fields-stand" title="Permalink"></a></h3><p>The standard fields are given as:</p><ul><li><strong><code>id</code></strong>:<br/>The field <code>id</code> is only used for providing a name to the node. This is similar to the approach utilized in <code>EnergyModelsBase</code>.</li><li><strong><code>cap::TimeProfile</code></strong>:<br/>The installed capacity corresponds to the potential usage of the node. The capacity does not have to correspond to the amount of hydrogen produced. Instead, it is relative to the specified <code>input</code> and <code>output</code> ratios. However, capacities of reformer are in general specified based on the produced hydrogen.<br/>If the node should contain investments through the application of <a href="https://energymodelsx.github.io/EnergyModelsInvestments.jl/stable/"><code>EnergyModelsInvestments</code></a>, it is important to note that you can only use <code>FixedProfile</code> or <code>StrategicProfile</code> for the capacity, but not <code>RepresentativeProfile</code> or <code>OperationalProfile</code>. In addition, all values have to be non-negative.</li><li><strong><code>opex_var::TimeProfile</code></strong>:<br/>The variable operational expenses are based on the capacity utilization through the variable <a href="https://energymodelsx.github.io/EnergyModelsBase.jl/stable/manual/optimization-variables/#man-opt_var-cap"><code>:cap_use</code></a>. Hence, it is directly related to the specified <code>input</code> and <code>output</code> ratios. The variable operating expenses can be provided as <code>OperationalProfile</code> as well.</li><li><strong><code>opex_fixed::TimeProfile</code></strong>:<br/>The fixed operating expenses are relative to the installed capacity (through the field <code>cap</code>) and the chosen duration of an investment period as outlined on <em><a href="https://energymodelsx.github.io/EnergyModelsBase.jl/stable/how-to/utilize-timestruct/#how_to-utilize_TS-struct-sp">Utilize <code>TimeStruct</code></a></em>.<br/>It is important to note that you can only use <code>FixedProfile</code> or <code>StrategicProfile</code> for the fixed OPEX, but not <code>RepresentativeProfile</code> or <code>OperationalProfile</code>. In addition, all values have to be non-negative.</li><li><strong><code>input::Dict{&lt;:Resource, &lt;:Real}</code></strong> and <strong><code>output::Dict{&lt;:Resource, &lt;:Real}</code></strong>:<br/>Both fields describe the <code>input</code> and <code>output</code> <a href="https://energymodelsx.github.io/EnergyModelsBase.jl/stable/library/public/resources/#EnergyModelsBase.Resource"><code>Resource</code></a>s with their corresponding conversion factors as dictionaries. In the case of a reformer, <code>input</code> should include <em>natural gas</em> and potentially <em>water</em> and <em>electricity</em> while the output is <em>hydrogen</em> and potentially <em>heat</em>, if included in the model, and <em>electricity</em>. Whether <em>electricity</em> is an <code>input</code> or <code>output</code> is depending on the process design for the reformer.<br/>All values have to be non-negative.</li><li><strong><code>data::Vector{Data}</code></strong>:<br/>An entry for providing additional data to the model. In the current state of electrolysis, it is only relevant for additional investment data when <a href="https://energymodelsx.github.io/EnergyModelsInvestments.jl/stable/"><code>EnergyModelsInvestments</code></a> is used.</li></ul><div class="admonition is-warning"><header class="admonition-header">CO₂ as output</header><div class="admonition-body"><p>If you include CO₂ capture through the application of <a href="https://energymodelsx.github.io/EnergyModelsBase.jl/stable/library/public/model_data/#EnergyModelsBase.CaptureData"><code>CaptureData</code></a> (explained on the page <a href="https://energymodelsx.github.io/EnergyModelsBase.jl/stable/manual/data-functions/#man-data_fun-emissions"><em>Data functions</em></a>), you have to add your CO₂ instance as output to the dictionary. The chosen value is not important, as the CO₂ outlet flow is calculated based on the CO₂ intensity of the fuel and the chosen capture rate.</p></div></div><h3 id="nodes-ref-fields-new"><a class="docs-heading-anchor" href="#nodes-ref-fields-new">Additional fields</a><a id="nodes-ref-fields-new-1"></a><a class="docs-heading-anchor-permalink" href="#nodes-ref-fields-new" title="Permalink"></a></h3><ul><li><strong><code>load_limits::LoadLimits</code></strong>:<br/>The <code>load_limits</code> specify the lower and upper limit for operating the reformer plant. These limits are included through the type <a href="../../library/public/#EnergyModelsHydrogen.LoadLimits"><code>LoadLimits</code></a> and correspond to a fraction of the installed capacity as described in <em><a href="../../library/public/#lib-pub-add-load_limit">Limiting the load</a></em>.<br/>The lower limit has to be non-negative while the upper limit has to be higher than the lower limit.</li><li><strong><code>startup::CommitParameters</code></strong>, <strong><code>shutdown::CommitParameters</code></strong>, and <strong><code>offline::CommitParameters</code></strong>:<br/>The fields <code>startup</code>, <code>shutdown</code>, and <code>offline</code> specify the required parameters for unit commitment. These parameters are included through the type <a href="../../library/public/#EnergyModelsHydrogen.CommitParameters"><code>CommitParameters</code></a> and correspond to both a stage cost and minium time in a stage as described in <em><a href="../../library/public/#lib-pub-add-unit_commit">Unit commitment</a></em>.<br/>It is important to note that you can only use <code>FixedProfile</code>, <code>StrategicProfile</code>, or <code>RepresentativeProfile</code> for the time profiles, but not <code>OperationalProfile</code>. In addition, all values have to be non-negative.</li><li><strong><code>rate_limit::TimeProfile</code></strong>:<br/>The <code>rate_limit</code> specifies the maximum allowed change in the relative capacity utilization of the reformer in a duration of 1 of an operational period as outlined on <em><a href="https://energymodelsx.github.io/EnergyModelsBase.jl/stable/how-to/utilize-timestruct/#how_to-utilize_TS-struct-sp">Utilize <code>TimeStruct</code></a></em>. Different types can be incorporated having constraints on the positive (<code>RampUp</code> and <code>RampBi</code>) or negative (<code>RampDown</code> and <code>RampBi</code>) allowed change as described in <em><a href="../../library/public/#lib-pub-add-ramping">Change of utilization</a></em>. Constraints are only created when required by the composite type.<br/>All values have to be in range <span>$[0,1]$</span>.</li></ul><h2 id="nodes-ref-math"><a class="docs-heading-anchor" href="#nodes-ref-math">Mathematical description</a><a id="nodes-ref-math-1"></a><a class="docs-heading-anchor-permalink" href="#nodes-ref-math" title="Permalink"></a></h2><p>In the following mathematical equations, we use the name for variables and functions used in the model. Variables are in general represented as</p><p><span>$\texttt{var\_example}[index_1, index_2]$</span></p><p>with square brackets, while functions are represented as</p><p><span>$func\_example(index_1, index_2)$</span></p><p>with paranthesis.</p><h3 id="nodes-ref-math-var"><a class="docs-heading-anchor" href="#nodes-ref-math-var">Variables</a><a id="nodes-ref-math-var-1"></a><a class="docs-heading-anchor-permalink" href="#nodes-ref-math-var" title="Permalink"></a></h3><h4 id="nodes-ref-math-var-stand"><a class="docs-heading-anchor" href="#nodes-ref-math-var-stand">Standard variables</a><a id="nodes-ref-math-var-stand-1"></a><a class="docs-heading-anchor-permalink" href="#nodes-ref-math-var-stand" title="Permalink"></a></h4><p>The reformer node types utilize all standard variables from the <code>RefNetworkNode</code>, as described on the page <em><a href="https://energymodelsx.github.io/EnergyModelsBase.jl/stable/manual/optimization-variables/#man-opt_var">Optimization variables</a></em>. The variables include:</p><ul><li><a href="https://energymodelsx.github.io/EnergyModelsBase.jl/stable/manual/optimization-variables/#man-opt_var-opex"><span>$\texttt{opex\_var}$</span></a></li><li><a href="https://energymodelsx.github.io/EnergyModelsBase.jl/stable/manual/optimization-variables/#man-opt_var-opex"><span>$\texttt{opex\_fixed}$</span></a></li><li><a href="https://energymodelsx.github.io/EnergyModelsBase.jl/stable/manual/optimization-variables/#man-opt_var-cap"><span>$\texttt{cap\_use}$</span></a></li><li><a href="https://energymodelsx.github.io/EnergyModelsBase.jl/stable/manual/optimization-variables/#man-opt_var-cap"><span>$\texttt{cap\_inst}$</span></a></li><li><a href="https://energymodelsx.github.io/EnergyModelsBase.jl/stable/manual/optimization-variables/#man-opt_var-flow"><span>$\texttt{flow\_in}$</span></a></li><li><a href="https://energymodelsx.github.io/EnergyModelsBase.jl/stable/manual/optimization-variables/#man-opt_var-flow"><span>$\texttt{flow\_out}$</span></a></li></ul><h4 id="nodes-ref-math-add"><a class="docs-heading-anchor" href="#nodes-ref-math-add">Additional variables</a><a id="nodes-ref-math-add-1"></a><a class="docs-heading-anchor-permalink" href="#nodes-ref-math-add" title="Permalink"></a></h4><p>Reformer nodes declare in addition several variables through dispatching on the method <a href="../../library/internals/methods-EMB/#EnergyModelsBase.variables_node"><code>EnergyModelsBase.variables_node()</code></a> for including the unit commitment constraints. These variables are for reformer node <span>$n_{ref}$</span> in operational period <span>$t$</span>:</p><ul><li><span>$\texttt{ref\_off\_b}[n_{ref}, t]$</span>: Offline indicator,</li><li><span>$\texttt{ref\_start\_b}[n_{ref}, t]$</span>: Startup indicator,</li><li><span>$\texttt{ref\_on\_b}[n_{ref}, t]$</span>: Online indicator, and</li><li><span>$\texttt{ref\_shut\_b}[n_{ref}, t]$</span>: Shutdown indicator.</li></ul><p>These variables are <strong><em>binary</em></strong> variables which indicate in which state the reformer is operating. A value of 1 corresponds to an operation in the given stage while a value of 0 implies that the reformer is not operating in a different state</p><h3 id="nodes-ref-math-con"><a class="docs-heading-anchor" href="#nodes-ref-math-con">Constraints</a><a id="nodes-ref-math-con-1"></a><a class="docs-heading-anchor-permalink" href="#nodes-ref-math-con" title="Permalink"></a></h3><p>The following sections omit the direction inclusion of the vector of reformer nodes. Instead, it is implicitly assumed that the constraints are valid <span>$\forall n_{ref} ∈ N^{Ref}$</span> for all <a href="../../library/public/#EnergyModelsHydrogen.Reformer"><code>Reformer</code></a> types if not stated differently. In addition, all constraints are valid <span>$\forall t \in T$</span> (that is in all operational periods) or <span>$\forall t_{inv} \in T^{Inv}$</span> (that is in all investment periods).</p><h4 id="nodes-ref-math-con-stand"><a class="docs-heading-anchor" href="#nodes-ref-math-con-stand">Standard constraints</a><a id="nodes-ref-math-con-stand-1"></a><a class="docs-heading-anchor-permalink" href="#nodes-ref-math-con-stand" title="Permalink"></a></h4><p>Reformer nodes utilize only a small set of the standard constraints described on <em><a href="https://energymodelsx.github.io/EnergyModelsBase.jl/stable/manual/constraint-functions/#man-con">Constraint functions</a></em>. These standard constraints are:</p><ul><li><p><code>constraints_capacity_installed</code>:</p><p class="math-container">\[\texttt{cap\_inst}[n_{ref}, t] = capacity(n_{ref}, t)\]</p><div class="admonition is-success"><header class="admonition-header">Using investments</header><div class="admonition-body"><p>The function <code>constraints_capacity_installed</code> is also used in <a href="https://energymodelsx.github.io/EnergyModelsInvestments.jl/stable/"><code>EnergyModelsInvestments</code></a> to incorporate the potential for investment. Nodes with investments are then no longer constrained by the parameter capacity.</p></div></div></li><li><p><code>constraints_flow_in</code>:</p><p class="math-container">\[\texttt{flow\_in}[n_{ref}, t, p] = inputs(n_{ref}, p) \times \texttt{cap\_use}[n_{ref}, t]
\qquad \forall p \in inputs(n_{ref})\]</p></li><li><p><code>constraints_flow_out</code>:</p><p class="math-container">\[\texttt{flow\_out}[n_{ref}, t, p] =
outputs(n_{ref}, p) \times \texttt{cap\_use}[n_{ref}, t]
\qquad \forall p \in outputs(n_{ref}) \setminus \{\text{CO}_2\}\]</p></li><li><p><code>constraints_opex_fixed</code>:</p><p class="math-container">\[\texttt{opex\_fixed}[n_{ref}, t_{inv}] = opex\_fixed(n_{ref}, t_{inv}) \times \texttt{cap\_inst}[n_{ref}, first(t_{inv})]\]</p><div class="admonition is-success"><header class="admonition-header">Why do we use `first()`</header><div class="admonition-body"><p>The variables <span>$\texttt{stor\_level\_inst}$</span> are declared over all operational periods (see the section on <em><a href="https://energymodelsx.github.io/EnergyModelsBase.jl/stable/manual/optimization-variables/#man-opt_var-cap">Capacity variables</a></em> for further explanations). Hence, we use the function <span>$first(t_{inv})$</span> to retrieve the installed capacities in the first operational period of a given investment period <span>$t_{inv}$</span> in the function <code>constraints_opex_fixed</code>.</p></div></div></li><li><p><code>constraints_data</code>:<br/>This function is only called for specified data of the reformer, see above.</p></li></ul><p>The function <code>constraints_capacity_installed</code> is also used in <a href="https://energymodelsx.github.io/EnergyModelsInvestments.jl/stable/"><code>EnergyModelsInvestments</code></a> to incorporate the potential for investment. Nodes with investments are then no longer constrained by the parameter capacity.</p><p>The variable <span>$\texttt{cap\_inst}$</span> is declared over all operational periods (see the section on <em><a href="https://energymodelsx.github.io/EnergyModelsBase.jl/stable/manual/optimization-variables/#man-opt_var-cap">Capacity variables</a></em> for further explanations). Hence, we use the function <span>$first(t_{inv})$</span> to retrieve the installed capacity in the first operational period of a given investment period <span>$t_{inv}$</span> in the function <code>constraints_opex_fixed</code>.</p><p>The function <code>constraints_capacity</code> is extended with a new method for reformer nodes to account for the minimum and maximum load:</p><p class="math-container">\[\begin{aligned}
\texttt{cap\_use}[n_{ref}, t] &amp; \geq
min\_load(n_{ref}, t) \times \texttt{ref\_on\_b}[n_{ref}, t] \times capacity(n_{ref}, t) \\
\texttt{cap\_use}[n_{ref}, t] &amp; \leq
max\_load(n_{ref}, t) \times \texttt{ref\_on\_b}[n_{ref}, t] \times capacity(n_{ref}, t)
\end{aligned}\]</p><p>In the case of investment potential in the node, this constraint is reformulated as:</p><p class="math-container">\[\begin{aligned}
\texttt{cap\_use}[n_{ref}, t] &amp; \geq
min\_load(n_{ref}, t) \times \texttt{ref\_on\_b}[n_{ref}, t] \times \texttt{cap\_inst}[n_{ref}, t] \\
\texttt{cap\_use}[n_{ref}, t] &amp; \leq
max\_load(n_{ref}, t) \times \texttt{ref\_on\_b}[n_{ref}, t] \times \texttt{cap\_inst}[n_{ref}, t]
\end{aligned}\]</p><p>resulting in a bilinear term of a binary and continuous variable.</p><div class="admonition is-success"><header class="admonition-header">Handling of bilinearities</header><div class="admonition-body"><p>Bilinearities of this type can be reformulated as linear problem through an auxiliary variable. <code>EnergyModelsHydrogen</code> provides a linear reformulation through the function <a href="../../library/internals/methods-EMH/#EnergyModelsHydrogen.linear_reformulation"><code>EnergyModelsHydrogen.linear_reformulation</code></a>. The linear reformulation is also explained in <em><a href="../../aux-fun/lin-reform/#aux-lin_reform-bin_con">Linear reformulation</a></em>. <span>$\texttt{cap\_inst}[n_{ref}, t]$</span> is replaced with <span>$capacity(n_{ref}, t)$</span> if the node does not have the potential for investments. The implementation uses the function <a href="../../library/internals/methods-EMH/#EnergyModelsHydrogen.multiplication_variables"><code>EnergyModelsHydrogen.multiplication_variables</code></a> for determining which approach should be chosen.</p><p>The function <code>multiplication_variables</code> is only called once for each bilinearity to avoid creating the auxiliary variable multiple times.</p></div></div><p>The function <code>constraints_opex_var</code> is extended with a new method for a reformer node to account for the costs associated to be within a given state:</p><p class="math-container">\[\begin{aligned}
\texttt{opex\_var}&amp;[n_{ref}, t] = \sum_{t \in t_{inv}} ( \\ &amp;
opex\_var(n_{ref}, t) \times \texttt{cap\_inst}[n_{ref}, t] + \\ &amp;
opex\_startup(n_{ref}, t) \times \texttt{cap\_inst}[n_{ref}, t] \times \texttt{ref\_start\_b}[n_{ref}, t] + \\ &amp;
opex\_shutdown_(n_{ref}, t) \times \texttt{cap\_inst}[n_{ref}, t] \times \texttt{ref\_shut\_b}[n_{ref}, t] + \\ &amp;
opex\_off(n_{ref}, t) \times \texttt{cap\_inst}[n_{ref}, t] \times \texttt{ref\_off\_b}[n_{ref}, t] \\ &amp;
) \times scale\_op\_sp(t_{inv}, t)
\end{aligned}\]</p><div class="admonition is-success"><header class="admonition-header">The function `scale_op_sp`</header><div class="admonition-body"><p>The function <a href="https://energymodelsx.github.io/EnergyModelsBase.jl/stable/library/public/functions/#EnergyModelsBase.scale_op_sp"><span>$scale\_op\_sp(t_{inv}, t)$</span></a> calculates the scaling factor between operational and investment periods. It also takes into account potential operational scenarios and their probability as well as representative periods.</p></div></div><p>The linear reformulation is also explained in <em><a href="../../aux-fun/lin-reform/#aux-lin_reform-bin_con">Linear reformulation</a></em>, as explained previously. Similarly, <span>$\texttt{cap\_inst}[n_{ref}, t]$</span> is replaced with <span>$capacity(n_{ref}, t)$</span> if the node does not have the potential for investments.</p><h4 id="nodes-ref-math-con-add"><a class="docs-heading-anchor" href="#nodes-ref-math-con-add">Additional constraints</a><a id="nodes-ref-math-con-add-1"></a><a class="docs-heading-anchor-permalink" href="#nodes-ref-math-con-add" title="Permalink"></a></h4><h5 id="nodes-ref-math-con-add-node"><a class="docs-heading-anchor" href="#nodes-ref-math-con-add-node">Constraints calculated in <code>create_node</code></a><a id="nodes-ref-math-con-add-node-1"></a><a class="docs-heading-anchor-permalink" href="#nodes-ref-math-con-add-node" title="Permalink"></a></h5><p>A reformer node can only be in a single stage in a given operational period <span>$t$</span>. This is enforced through a single constraint given as</p><p class="math-container">\[\texttt{ref\_off\_b}[n_{ref}, t] + \texttt{ref\_start\_b}[n_{ref}, t] + \texttt{ref\_on\_b}[n_{ref}, t] + \texttt{ref\_shut\_b}[n_{ref}, t] = 1\]</p><h5 id="nodes-ref-math-con-add-fun"><a class="docs-heading-anchor" href="#nodes-ref-math-con-add-fun">Constraints through separate functions</a><a id="nodes-ref-math-con-add-fun-1"></a><a class="docs-heading-anchor-permalink" href="#nodes-ref-math-con-add-fun" title="Permalink"></a></h5><p>Within the function <code>create_node</code>, we iterate the through the investment periods to call three functions, <a href="../../library/internals/methods-EMH/#EnergyModelsHydrogen.constraints_rate_of_change_iterate"><code>EnergyModelsHydrogen.constraints_rate_of_change_iterate</code></a> for enforcing the limit on the rate of change, <a href="../../library/internals/methods-EMH/#EnergyModelsHydrogen.constraints_state_seq_iter"><code>EnergyModelsHydrogen.constraints_state_seq_iter</code></a> for enforcing the correct sequencing of the individual states, and <a href="../../library/internals/methods-EMH/#EnergyModelsHydrogen.constraints_state_time_iter"><code>EnergyModelsHydrogen.constraints_state_time_iter</code></a> for enforcing the minimum time a node has to be in a given state. All functions iterate through the individual time structures (investment periods, representative periods, operational scenarios) to calculate the proper constraints based on the chosen time structure. All functions utilize a cyclic approach in which the last operational period <span>$t_{last}$</span> within an investment period (representative period, if included, or operational scenario, if included) is required to be passed to the constraint.</p><p>As outlined, the function <code>constraints_rate_of_change_iterate</code> iterates through the time structure to determine the correct last operational period. Both the previous, the current, and the last operational periods are then passed to a instance of the parametric type  <a href="../../library/internals/types-EMH/#EnergyModelsHydrogen.RefPeriods"><code>EnergyModelsHydrogen.RefPeriods</code></a> which allows to either extract the last or previous period using the function  <a href="../../library/internals/methods-fields/#EnergyModelsHydrogen.prev_op"><code>EnergyModelsHydrogen.prev_op</code></a>, depending on whether the previous period <span>$t_{prev}$</span> is <code>nothing</code>. The general approach for a rate of change constraint is given by</p><p class="math-container">\[\begin{aligned}
\texttt{cap\_use}[n_{ref}, t] - \texttt{ref\_on\_b}[n_{ref}, t_{prev}] &amp; \leq \texttt{cap\_inst}[n, t] \times ramp\_up(n_{ref}, t) \times duration(t) \\
\texttt{cap\_use}[n_{ref}, t_{prev}] - \texttt{ref\_on\_b}[n_{ref}, t] &amp; \leq \texttt{cap\_inst}[n, t] \times ramp\_down(n_{ref}, t) \times duration(t)
\end{aligned}\]</p><p>Both constraints have to be included to limit the rate of change both if the capacity utilization is increasing and decreasing. The reformer node should also be allowed to go from the state <em>startup</em> to any capacity utilization as well as from any capacity utilization to the state <em>shutdown</em>. This implies that the constraints should only be active, if <span>$\texttt{ref\_on\_b}[n_{ref}, t] = \texttt{ref\_on\_b}[n_{ref}, t_{prev}] = 1$</span> corresponding to a disjunction.</p><p>This is achieved through rewriting the rate of change constraints using the convex-hull reformulation (which is similar to the Big-M reformulation in this specific instance):</p><p class="math-container">\[\begin{aligned}
\texttt{cap\_use}[n_{ref}, t] - &amp; \texttt{ref\_on\_b}[n_{ref}, t_{prev}] \leq \\ &amp;
\texttt{cap\_inst}[n, t] \times ramp\_up(n_{ref}, t) * duration(t) + \\ &amp;
capacity(n_{ref}, t) \times (2 - \texttt{ref\_on\_b}[n_{ref}, t] - \texttt{ref\_on\_b}[n_{ref}, t_{prev}])
\end{aligned}\]</p><div class="admonition is-success"><header class="admonition-header">How does it work?</header><div class="admonition-body"><p>We can differentiate the constraint into three different cases:</p><ol><li>Consider the case in which <span>$\texttt{ref\_on\_b}[n_{ref}, t] = \texttt{ref\_on\_b}[n_{ref}, t_{prev}] = 1$</span>. The second term cancels out in this situation resulting in the original rate of change constraints.</li><li>If <span>$\texttt{ref\_on\_b}[n_{ref}, t] \neq \texttt{ref\_on\_b}[n_{ref}, t_{prev}]$</span> we experience a change in state. In this situation, it should be possible to move from 100 % capacity utilization to 0 % or <em>vice versa</em>. This is allowed as the second term corresponds to <span>$capacity(n, t)$</span>.</li><li>If <span>$\texttt{ref\_on\_b}[n_{ref}, t] = \texttt{ref\_on\_b}[n_{ref}, t_{prev}] = 0$</span>, this constraint is no longer relevant as the capacity utilization is already limited in other constraints. It would however be possible, if not restricted by other constraints, to increase the utilization from 0 to 100 % in a single operational period.</li></ol></div></div><p>The function <span>$capacity$</span> of the node is replaced with the function <span>$max_installed(investment_data())$</span> If you utilize <code>EnergyModelsInvestments</code> and the reformer node has the potential for investment.</p><p>The function <code>constraints_state_seq_iter</code> utlizes the same iteration approach as the function <code>constraints_rate_of_change_iterate</code>. The constraint is eventually included through the function <a href="../../library/internals/methods-EMH/#EnergyModelsHydrogen.constraints_state_seq"><code>EnergyModelsHydrogen.constraints_state_seq</code></a> in which the sequencing constraints are included:</p><p class="math-container">\[\begin{aligned}
\texttt{ref\_off\_b}[n_{ref}, t_{prev}] &amp; \geq \texttt{ref\_start\_b}[n_{ref}, t] - \texttt{ref\_start\_b}[n_{ref}, t_{prev}] \\
\texttt{ref\_start\_b}[n_{ref}, t_{prev}] &amp; \geq \texttt{ref\_on\_b}[n_{ref}, t] - \texttt{ref\_on\_b}[n_{ref}, t_{prev}] \\
\texttt{ref\_on\_b}[n_{ref}, t_{prev}] &amp; \geq \texttt{ref\_shut\_b}[n_{ref}, t] - \texttt{ref\_shut\_b}[n_{ref}, t_{prev}] \\
\texttt{ref\_shut\_b}[n_{ref}, t_{prev}] &amp; \geq \texttt{ref\_off\_b}[n_{ref}, t] - \texttt{ref\_off\_b}[n_{ref}, t_{prev}] \\
\end{aligned}\]</p><p>If the previous period <span>$t_{prev}$</span> is <code>nothing</code>, it is replaced by <span>$t_{last}$</span>.</p><div class="admonition is-success"><header class="admonition-header">How does it work?</header><div class="admonition-body"><p>Consider a case in which the former was in the  previous period <span>$t_{prev}$</span> offline. In this situation, we wil;l have <span>$\texttt{ref\_off\_b}[n_{ref}, t_{prev}] = 1$</span> while <span>$\texttt{ref\_start\_b}[n_{ref}, t_{prev}] = 0$</span>, <span>$\texttt{ref\_on\_b}[n_{ref}, t_{prev}] = 0$</span>, and <span>$\texttt{ref\_shut\_b}[n_{ref}, t_{prev}] = 0$</span>.</p><ul><li>Constraint 1 implies that <span>$\texttt{ref\_start\_b}[n_{ref}, t]$</span> can be either 0 or 1.</li><li>Constraints 2 and 3 enforce that both <span>$\texttt{ref\_on\_b}[n_{ref}, t]$</span> and <span>$\texttt{ref\_shut\_b}[n_{ref}, t]$</span> are 0 as the left hand side is 0.</li><li>Constraint 4 implies <span>$\texttt{ref\_off\_b}[n_{ref}, t]$</span> can be either 0 or 1.</li></ul><p>As a consequence, we can either remain in the state <em>offline</em> or proceed to the state <em>startup</em>.</p></div></div><p>The function <code>constraints_state_time_iter</code> utlizes the same iteration approach as the function <code>constraints_state_seq_iter</code>. However, we calculate the the constraints within the function when the operatioanl time structure is given as <code>SimpleTimes</code>. The implementation can utilize different lengths within each state as well as variations in the duration of operational periods. This is achieved through the function <a href="https://sintefore.github.io/TimeStruct.jl/stable/reference/api/#TimeStruct.chunk_duration"><code>TimeStruct.chunk_duration</code></a> which provides an iterator of time chuncks of at least a given duration.</p><p>The constraints are cyclic constraints which utilize the function <code>zip</code> to obtain a combined iterator of the individual <code>chunk_duration</code> iterators and the current operational period.</p><p>This approach is best explained with an example in which we want to force the model to be at least <span>$time\_startup$</span> in the startup state: Consider an operational period <span>$t$</span>, its previous operator <span>$t_{prev}$</span>, and the chunck <span>$t_{next, start}$</span> which corresponds to an iterator for the next <span>$n$</span> operational periods so that the duration of the iterator including the operational period <span>$t$</span> is at least as large as the provided value <span>$time\_startup$</span>.</p><p>The constraint is then given as</p><p class="math-container">\[\begin{aligned}
\sum_{\theta \in t_{next, start}}&amp; \texttt{ref\_start\_b}[m_{ref}, \theta] \geq \\ &amp;
time\_startup(n_{ref}, t) \times (\texttt{ref\_start\_b}[m_{ref}, t]-\texttt{ref\_start\_b}[m_{ref}, t_{prev}])
\end{aligned}\]</p><p>It enforces in the case of a state change from 0 to 1 between the previous periods <span>$t_{prev}$</span> and the current period <span>$t$</span> that the periods following <span>$t$</span> up to a total duration of <span>$time\_startup$</span> are also 1.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../electrolyzer/">« Electrolyzer</a><a class="docs-footer-nextpage" href="../h2_storage/">H₂ storage »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Monday 16 December 2024 14:40">Monday 16 December 2024</span>. Using Julia version 1.11.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

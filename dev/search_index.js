var documenterSearchIndex = {"docs":
[{"location":"how-to/contribute/#how_to-con","page":"Contribute to EnergyModelsHydrogen","title":"Contribute to EnergyModelsHydrogen","text":"","category":"section"},{"location":"how-to/contribute/","page":"Contribute to EnergyModelsHydrogen","title":"Contribute to EnergyModelsHydrogen","text":"Contributing to EnergyModelsHydrogen can be achieved in several different ways.","category":"page"},{"location":"how-to/contribute/#how_to-con-bug_rep","page":"Contribute to EnergyModelsHydrogen","title":"File a bug report","text":"","category":"section"},{"location":"how-to/contribute/","page":"Contribute to EnergyModelsHydrogen","title":"Contribute to EnergyModelsHydrogen","text":"Another approach to contributing to EnergyModelsHydrogen is through filing a bug report as an issue when unexpected behaviour is occuring.","category":"page"},{"location":"how-to/contribute/","page":"Contribute to EnergyModelsHydrogen","title":"Contribute to EnergyModelsHydrogen","text":"When filing a bug report, please follow the following guidelines:","category":"page"},{"location":"how-to/contribute/","page":"Contribute to EnergyModelsHydrogen","title":"Contribute to EnergyModelsHydrogen","text":"Be certain that the bug is a bug and originating in EnergyModelsHydrogen:\nIf the problem is within the results of the optimization problem, please check first that the nodes are correctly linked with each other. Frequently, missing links (or wrongly defined links) restrict the transport of energy/mass. If you are certain that all links are set correctly, it is most likely a bug in EnergyModelsHydrogen and should be reported.\nIf the problem occurs in model construction, it is most likely a bug in either EnergyModelsBase or EnergyModelsHydrogen and should be reported in the respective package. The error message of Julia should provide you with the failing function and whether the failing function is located in EnergyModelsBase or EnergyModelsHydrogen. It can occur, that the last shown failing function is within JuMP or MathOptInterface. In this case, it is best to trace the error to the last called EnergyModelsBase or EnergyModelsHydrogen function.\nIf the problem is only appearing for specific solvers, it is most likely not a bug in EnergyModelsHydrogen, but instead a problem of the solver wrapper for MathOptInterface. In this case, please contact the developers of the corresponding solver wrapper.\nLabel the issue as bug, and\nProvide a minimum working example of a case in which the bug occurs.","category":"page"},{"location":"how-to/contribute/#how_to-con-feat_req","page":"Contribute to EnergyModelsHydrogen","title":"Feature requests","text":"","category":"section"},{"location":"how-to/contribute/","page":"Contribute to EnergyModelsHydrogen","title":"Contribute to EnergyModelsHydrogen","text":"EnergyModelsHydrogen includes several new nodal descriptions for hydrogen technologies. However, there can be a demand for additional requirements for the existing nodes or for new descriptions which fall below the umbrella of hydrogen technologies. In this case, you can contribute through a feature request.","category":"page"},{"location":"how-to/contribute/","page":"Contribute to EnergyModelsHydrogen","title":"Contribute to EnergyModelsHydrogen","text":"Feature requests for EnergyModelsHydrogen should follow the guidelines developed for EnergyModelsBase.","category":"page"},{"location":"how-to/contribute/","page":"Contribute to EnergyModelsHydrogen","title":"Contribute to EnergyModelsHydrogen","text":"note: Note\nEnergyModelsHydrogen is slightly different than EnergyModelsBase.Contrary to the other package, we consider that it is beneficial to have all potential features of hydrogen technologies within EnergyModelsHydrogen. Hence, if you have a requirement for a new nodal description, do not hesitate to create an issue.","category":"page"},{"location":"library/internals/types-EMH/#lib-int-types","page":"Types","title":"Types","text":"","category":"section"},{"location":"library/internals/types-EMH/#lib-int-types-idx","page":"Types","title":"Index","text":"","category":"section"},{"location":"library/internals/types-EMH/","page":"Types","title":"Types","text":"Pages = [\"types-EMH.md\"]","category":"page"},{"location":"library/internals/types-EMH/#lib-int-types-node","page":"Types","title":"Nodal supertypes","text":"","category":"section"},{"location":"library/internals/types-EMH/","page":"Types","title":"Types","text":"EnergyModelsHydrogen.AbstractHydrogenNetworkNode\nEnergyModelsHydrogen.AbstractElectrolyzer\nEnergyModelsHydrogen.AbstractReformer\nEnergyModelsHydrogen.AbstractH2Storage","category":"page"},{"location":"library/internals/types-EMH/#EnergyModelsHydrogen.AbstractHydrogenNetworkNode","page":"Types","title":"EnergyModelsHydrogen.AbstractHydrogenNetworkNode","text":"Abstract supertype for all hydrogen network nodes.\n\n\n\n\n\n","category":"type"},{"location":"library/internals/types-EMH/#EnergyModelsHydrogen.AbstractElectrolyzer","page":"Types","title":"EnergyModelsHydrogen.AbstractElectrolyzer","text":"AbstractElectrolyzer <: AbstractHydrogenNetworkNode\n\nAbstract supertype for all electrolyzer nodes.\n\n\n\n\n\n","category":"type"},{"location":"library/internals/types-EMH/#EnergyModelsHydrogen.AbstractReformer","page":"Types","title":"EnergyModelsHydrogen.AbstractReformer","text":"Abstract supertype for all reformer nodes.\n\n\n\n\n\n","category":"type"},{"location":"library/internals/types-EMH/#EnergyModelsHydrogen.AbstractH2Storage","page":"Types","title":"EnergyModelsHydrogen.AbstractH2Storage","text":"AbstractH2Storage{T} <: Storage{T}\n\nAbstract type for different implementations of hydrogen storage nodes.\n\n\n\n\n\n","category":"type"},{"location":"library/internals/types-EMH/#lib-int-types-para","page":"Types","title":"Parameter supertypes","text":"","category":"section"},{"location":"library/internals/types-EMH/","page":"Types","title":"Types","text":"EnergyModelsHydrogen.AbstractLoadLimits\nEnergyModelsHydrogen.AbstractRampParameters","category":"page"},{"location":"library/internals/types-EMH/#EnergyModelsHydrogen.AbstractLoadLimits","page":"Types","title":"EnergyModelsHydrogen.AbstractLoadLimits","text":"AbstractLoadLimits{T}\n\nAbstract type for the load limits. This type can be used to incorporate other types for the load limit.\n\n\n\n\n\n","category":"type"},{"location":"library/internals/types-EMH/#EnergyModelsHydrogen.AbstractRampParameters","page":"Types","title":"EnergyModelsHydrogen.AbstractRampParameters","text":"AbstractRampParameters\n\nAbstract type for different ramp parameter configurations.\n\n\n\n\n\n","category":"type"},{"location":"library/internals/types-EMH/#lib-int-types-aux","page":"Types","title":"Auxiliary types","text":"","category":"section"},{"location":"library/internals/types-EMH/","page":"Types","title":"Types","text":"EnergyModelsHydrogen.ElecPeriods\nEnergyModelsHydrogen.RefPeriods","category":"page"},{"location":"library/internals/types-EMH/#EnergyModelsHydrogen.ElecPeriods","page":"Types","title":"EnergyModelsHydrogen.ElecPeriods","text":"ElecPeriods\n\nContains information for calculating the constraints for AbstractElectrolyzer node types.\n\nFields\n\nsps::TS.AbstractStratPers are the strategic periods of the TimeStructure.\nsp::TS.AbstractStrategicPeriod is the current strategic period.\nop::TS.AbstractStrategicPeriod is the current operational period.\nlast::Bool is a boolean indicator of the last period. It is used for calculating the bounds for the last operational periods within a strategic period.\n\n\n\n\n\n","category":"type"},{"location":"library/internals/types-EMH/#EnergyModelsHydrogen.RefPeriods","page":"Types","title":"EnergyModelsHydrogen.RefPeriods","text":"RefPeriods{S<:Union{TS.OperationalPeriod, Nothing}}\n\nContains information for calculating the constraints for Reformer node types.\n\nFields\n\nprevious::S is the previous operational period received from the withprev iterator\ncurrent::TS.OperationalPeriod is the current operational period.\nlast::TS.OperationalPeriod is the last operational period in the current SimpleTimes structure within a strategic period (or representative period, if present, or operational scenario, if present).\n\n\n\n\n\n","category":"type"},{"location":"nodes/electrolyzer/#nodes-elec","page":"Electrolyzer","title":"Electrolyzer nodes","text":"","category":"section"},{"location":"nodes/electrolyzer/","page":"Electrolyzer","title":"Electrolyzer","text":"Electrolysis plants can be separated between the electrolysis stack and the balance of plant. While the former is the core of the plant for the production of hydrogen, it experiences degradation resulting in a reduced efficiency when utilizing the stack. The lifetime of the stack is furthermore reduced compared to the balance of plant. Hence, incorporating the potential for stack replacement and the associated costs may impact the utilization of the electrolyser given electricity availability and price.","category":"page"},{"location":"nodes/electrolyzer/","page":"Electrolyzer","title":"Electrolyzer","text":"Stack replacement is cheaper than rebuilding a complete plant. Furthermore, it results in an improved efficiency as it resets the degradation.","category":"page"},{"location":"nodes/electrolyzer/#nodes-elec-fields","page":"Electrolyzer","title":"Introduced types and their fields","text":"","category":"section"},{"location":"nodes/electrolyzer/","page":"Electrolyzer","title":"Electrolyzer","text":"Electrolysis is incorporated through two composite types with the same parameters. Both types are essentially equal, but SimpleElectrolyzer does not utilize the degradation of the stack for the calculation of a reduced efficiency as Electrolyzer. Instead, it utilizes it only for stack replacement calculations to avoid bilinear terms as constraints.","category":"page"},{"location":"nodes/electrolyzer/","page":"Electrolyzer","title":"Electrolyzer","text":"danger: Electrolysis with changing capacities\nThe stack degradation calculations do not consider a change in capacity. If you want to include investments or only an increased capacity over the course of time, you have to include several electrolysis nodes in which each node corresponds to the capacity in an investment period with a changing capacity.","category":"page"},{"location":"nodes/electrolyzer/#nodes-elec-fields-stand","page":"Electrolyzer","title":"Standard fields","text":"","category":"section"},{"location":"nodes/electrolyzer/","page":"Electrolyzer","title":"Electrolyzer","text":"The standard fields are given as:","category":"page"},{"location":"nodes/electrolyzer/","page":"Electrolyzer","title":"Electrolyzer","text":"id:\nThe field id is only used for providing a name to the node. This is similar to the approach utilized in EnergyModelsBase.\ncap::TimeProfile:\nThe installed capacity of the electrolysis node corresponds to the potential usage of the node. The capacity does not have to correspond to the amount of hydrogen produced. Instead, it is relative to the specified input and output ratios.\nIf the node should contain investments through the application of EnergyModelsInvestments, it is important to note that you can only use FixedProfile or StrategicProfile for the capacity, but not RepresentativeProfile or OperationalProfile. In addition, all values have to be non-negative.\nopex_var::TimeProfile:\nThe variable operational expenses of an electrolysis node are based on the capacity utilization through the variable :cap_use. Hence, it is directly related to the specified input and output ratios. The variable operating expenses can be provided as OperationalProfile as well.\nopex_fixed::TimeProfile:\nThe fixed operating expenses are relative to the installed capacity (through the field cap) and the chosen duration of an investment period as outlined on Utilize TimeStruct.\nIt is important to note that you can only use FixedProfile or StrategicProfile for the fixed OPEX, but not RepresentativeProfile or OperationalProfile. In addition, all values have to be non-negative.\ninput::Dict{<:Resource, <:Real} and output::Dict{<:Resource, <:Real}:\nBoth fields describe the input and output Resources with their corresponding conversion factors as dictionaries. In the case of electrolysis, input should include electricity and potentially water while the output is hydrogen and potentially heat, if included in the model.\nAll values have to be non-negative.\ndata::Vector{Data}:\nAn entry for providing additional data to the model. In the current version of electrolysis, it is only relevant for additional investment data when EnergyModelsInvestments is used.","category":"page"},{"location":"nodes/electrolyzer/","page":"Electrolyzer","title":"Electrolyzer","text":"warning: Capacity, opex, input and output\nThe fields capacity opex_var, opex_fixed, input and output dictionaries are directly linked.Consider a 10 MWₑₗ electrolyzer which has a maximum electricity input of 10 MW, and variable OPEX of 5 €/MWhₕ₂ (defined via the produced hydrogen), a fixed OPEX of 20000 €/MWₑₗ (defined via the electricity capacity), and an efficiency of 69 %. In this situation, you would specify the input ascap = FixedProfile(10)\nvar_opex = FixedProfile(5/.69)\nfixed_opex = FixedProfile(20000)\ninput = Dict(Electricity => 1)\noutput = Dict(Hydrogen => 0.69)As the variable OPEX is defined via the produced hydrogen, it is crucial to include the efficiency in the calculation as the model bases the calculation on a value of 1 in the input or output dictionary.","category":"page"},{"location":"nodes/electrolyzer/#nodes-elec-fields-new","page":"Electrolyzer","title":"Additional fields","text":"","category":"section"},{"location":"nodes/electrolyzer/","page":"Electrolyzer","title":"Electrolyzer","text":"load_limits::LoadLimits:\nThe load_limits specify the lower and upper limit for operating the electrolyzer. These limits are included through the type LoadLimits and correspond to a fraction of the installed capacity as described in Limiting the load.\nThe lower limit has to be non-negative while the upper limit has to be higher than the lower limit.\ndegradation_rate::Real:\nThe degradation rate is the reduction in efficiency of the electrolyser due to utilization. It has to be provided as a percentage drop in efficiency in 1000 time the length of an operational duration (see Utilize TimeStruct for an explanation). If a duration of 1 in an operational period corresponds to an hour, then the unit is %/1000h.\nThe degradation rate has to be given as 0 1).\nstack_replacement_cost::TimeProfile:\nThe stack replacement cost corresponds to the costs associated with stack replacement. It is smaller than the capital expenditures as only the stack has to be replaced. The cost is included in the fixed operational cost variable in the investment period in which stack replacement occurs.\nIt is important to note that you can only use FixedProfile or StrategicProfile for the stack replacment cost, but not RepresentativeProfile or OperationalProfile. In addition, all values have to be non-negative.\nstack_lifetime::Real:\nThe stack lifetime affects when the stack has to be replaced. The lifetime is given as multiple of the operational duration (see Utilize TimeStruct for an explanation). A typical value is in the range of 60000-100000 h in the case of an operational duration of 1 h.","category":"page"},{"location":"nodes/electrolyzer/#nodes-elec-math","page":"Electrolyzer","title":"Mathematical description","text":"","category":"section"},{"location":"nodes/electrolyzer/","page":"Electrolyzer","title":"Electrolyzer","text":"In the following mathematical equations, we use the name for variables and functions used in the model. Variables are in general represented as","category":"page"},{"location":"nodes/electrolyzer/","page":"Electrolyzer","title":"Electrolyzer","text":"textttvar_exampleindex_1 index_2","category":"page"},{"location":"nodes/electrolyzer/","page":"Electrolyzer","title":"Electrolyzer","text":"with square brackets, while functions are represented as","category":"page"},{"location":"nodes/electrolyzer/","page":"Electrolyzer","title":"Electrolyzer","text":"func_example(index_1 index_2)","category":"page"},{"location":"nodes/electrolyzer/","page":"Electrolyzer","title":"Electrolyzer","text":"with paranthesis.","category":"page"},{"location":"nodes/electrolyzer/#nodes-elec-math-var","page":"Electrolyzer","title":"Variables","text":"","category":"section"},{"location":"nodes/electrolyzer/#nodes-elec-math-var-stand","page":"Electrolyzer","title":"Standard variables","text":"","category":"section"},{"location":"nodes/electrolyzer/","page":"Electrolyzer","title":"Electrolyzer","text":"The electrolyser node types utilize all standard variables from the RefNetworkNode, as described on the page Optimization variables. The variables include:","category":"page"},{"location":"nodes/electrolyzer/","page":"Electrolyzer","title":"Electrolyzer","text":"textttopex_var\ntextttopex_fixed\ntextttcap_use\ntextttcap_inst\ntextttflow_in\ntextttflow_out","category":"page"},{"location":"nodes/electrolyzer/","page":"Electrolyzer","title":"Electrolyzer","text":"The variable textttopex_fixed also includes the cost of stack replacement in the investment periods in which stack replacement occurs.","category":"page"},{"location":"nodes/electrolyzer/#nodes-elec-math-add","page":"Electrolyzer","title":"Additional variables","text":"","category":"section"},{"location":"nodes/electrolyzer/","page":"Electrolyzer","title":"Electrolyzer","text":"Electrolyzer nodes declare in addition several variables through dispatching on the method EnergyModelsBase.variables_node(). These variables are:","category":"page"},{"location":"nodes/electrolyzer/","page":"Electrolyzer","title":"Electrolyzer","text":"textttelect_on_bn_el t: State of electrolyser node n_el in operational period t.\nThis variable is a binary variable which indiciates whether the electrolyser is on (1) or off (0). It is used in the calculation of the stack degradation and the lifetime of the electrolyser stack.\ntextttelect_prev_usen_el t: Usage of electrolyser node n_el up to operational period t.\nThe usage of the electrolyser node always corresponds to the accumulated usage since the beginning or the last stack replacement up to the previous period. Usage of the node in operational period t is not included in the calculation.\ntextttelect_prev_use_spn_el t_inv: Usage of electrolyser node n_el up to investment period t_inv.\nThe usage of the electrolyser node always corresponds to the accumulated usage since the beginning or the last stack replacement up to the current investment period. Usage of the node in investment period t_inv is not included in the calculation.\ntextttelect_use_spn_el t_inv: Usage of electrolyser node n_el in investment period t_inv.\nThis variable denotes the total usage within an investment period.\ntextttelect_use_rpn_el t_rp: Usage of electrolyser node n_el in representative period t_rp.\nThis variable denotes the total usage within a representative period, if the chosen TimeStructure includes RepresentativePeriods.\ntextttelect_stack_replace_bn_el t_inv: Indicator variable of electrolyser node n_el in investment period t_inv for stack replacement.\nThis variable is a binary variable which indiciates whether stack replacement is occuring at the beginning of  investment period t_inv (1) or not (0).\ntextttelect_efficiency_penaltyn_el t: Efficiency penalty of electrolyser node n_el in operational period t.\nThe efficiency penalty is calculated irrespectively whether you use a SimpleElectrolyzer or an Electrolyzer node. It is a multiplicator for the efficiency for hydrogen production and reset in the investment period in which stack replacement is occuring.","category":"page"},{"location":"nodes/electrolyzer/","page":"Electrolyzer","title":"Electrolyzer","text":"note: Units for usage variables\nThe variables textttelect_prev_usen_el t, textttelect_use_spn_el t_inv, and textttelect_use_rpn_el t_rp have the same unit. The units of the variables are given in 1000 times the operational duration of 1 (see Utilize TimeStruct for an explanation). If you use an hourly resolution, they would hence correspond to 1000 h.","category":"page"},{"location":"nodes/electrolyzer/#nodes-elec-math-con","page":"Electrolyzer","title":"Constraints","text":"","category":"section"},{"location":"nodes/electrolyzer/","page":"Electrolyzer","title":"Electrolyzer","text":"The following sections omit the direction inclusion of the vector of electrolyzer nodes. Instead, it is implicitly assumed that the constraints are valid forall n_el  N^EL, that is both SimpleElectrolyzer and Electrolyzer types if not stated differently. In addition, all constraints are valid forall t in T (that is in all operational periods) or forall t_inv in T^Inv (that is in all investment periods).","category":"page"},{"location":"nodes/electrolyzer/#nodes-elec-math-con-stand","page":"Electrolyzer","title":"Standard constraints","text":"","category":"section"},{"location":"nodes/electrolyzer/","page":"Electrolyzer","title":"Electrolyzer","text":"The different electrolyzer nodes utilize only a small set of the standard constraints described on Constraint functions. These standard constraints are:","category":"page"},{"location":"nodes/electrolyzer/","page":"Electrolyzer","title":"Electrolyzer","text":"constraints_capacity_installed:\ntextttcap_instn_el t = capacity(n_el t)\ntip: Using investments\nThe function constraints_capacity_installed is also used in EnergyModelsInvestments to incorporate the potential for investment. Nodes with investments are then no longer constrained by the parameter capacity.\nconstraints_flow_in:\ntextttflow_inn_el t p = inputs(n_el p) times textttcap_usen_el t\nqquad forall p in inputs(n_el)\nconstraints_opex_var:\ntextttopex_varn_el t_inv = sum_t in t_inv opex_var(n_el t) times textttcap_usen_el t times scale_op_sp(t_inv t)\ntip: The function `scale_op_sp`\nThe function scale_op_sp(t_inv t) calculates the scaling factor between operational and investment periods. It also takes into account potential operational scenarios and their probability as well as representative periods.\nconstraints_data:\nThis function is only called for specified data of the reformer, see above.","category":"page"},{"location":"nodes/electrolyzer/","page":"Electrolyzer","title":"Electrolyzer","text":"The SimpleElectrolyzer node utilizes in addition the default function constraints_flow_out:","category":"page"},{"location":"nodes/electrolyzer/","page":"Electrolyzer","title":"Electrolyzer","text":"textttflow_outn_el t p =\noutputs(n_el p) times textttcap_usen_el t\nqquad forall p in outputs(n_el) setminus textCO_2","category":"page"},{"location":"nodes/electrolyzer/","page":"Electrolyzer","title":"Electrolyzer","text":"while the Electrolyzer node dispatches on the  function constraints_flow_out to incorporate the efficiency penalty:","category":"page"},{"location":"nodes/electrolyzer/","page":"Electrolyzer","title":"Electrolyzer","text":"beginaligned\ntextttflow_outn_el t p =  \noutputs(n_el p) times textttcap_usen_el t times textttelect_efficiency_penaltyn_el t\nqquad forall p in outputs(n_el)\nendaligned","category":"page"},{"location":"nodes/electrolyzer/","page":"Electrolyzer","title":"Electrolyzer","text":"The incorporation of the efficiency penalty results in a bilinear term as it corresponds to a multiplication of two continuous variables, textttcap_usen_el t and textttelect_efficiency_penaltyn_el t. Hence, you have to utilize a solver that supports optimization problems with bilinear constraints.","category":"page"},{"location":"nodes/electrolyzer/","page":"Electrolyzer","title":"Electrolyzer","text":"The function constraints_capacity is extended with a new method for electrolyzer nodes to account for the minimum and maximum load:","category":"page"},{"location":"nodes/electrolyzer/","page":"Electrolyzer","title":"Electrolyzer","text":"beginaligned\ntextttcap_usen_el t  geq\nmin_load(n_el t) times textttelect_on_bn_el t times capacity(n_el t) \ntextttcap_usen_el t  leq\nmax_load(n_el t) times textttelect_on_bn_el t times capacity(n_el t)\nendaligned","category":"page"},{"location":"nodes/electrolyzer/","page":"Electrolyzer","title":"Electrolyzer","text":"In the case of investment potential in the node, this constraint is reformulated as:","category":"page"},{"location":"nodes/electrolyzer/","page":"Electrolyzer","title":"Electrolyzer","text":"beginaligned\ntextttcap_usen_el t  geq\nmin_load(n_el t) times textttelect_on_bn_el t times textttcap_instn_el t \ntextttcap_usen_el t  leq\nmax_load(n_el t) times textttelect_on_bn_el t times textttcap_instn_el t\nendaligned","category":"page"},{"location":"nodes/electrolyzer/","page":"Electrolyzer","title":"Electrolyzer","text":"resulting in a bilinear term of a binary and continuous variable.","category":"page"},{"location":"nodes/electrolyzer/","page":"Electrolyzer","title":"Electrolyzer","text":"tip: Handling of bilinearities\nBilinearities of this type can be reformulated as linear problem through an auxiliary variable. EnergyModelsHydrogen provides a linear reformulation through the function EnergyModelsHydrogen.linear_reformulation. The linear reformulation is also explained in Linear reformulation. textttcap_instn_el t is replaced with capacity(n_el t) if the node does not have the potential for investments. The implementation uses the function EnergyModelsHydrogen.multiplication_variables for determining which approach should be chosen.The function multiplication_variables is only called once for each bilinearity to avoid creating the auxiliary variable multiple times.","category":"page"},{"location":"nodes/electrolyzer/#nodes-elec-math-con-add","page":"Electrolyzer","title":"Additional constraints","text":"","category":"section"},{"location":"nodes/electrolyzer/#nodes-elec-math-con-add-node","page":"Electrolyzer","title":"Constraints calculated in create_node","text":"","category":"section"},{"location":"nodes/electrolyzer/","page":"Electrolyzer","title":"Electrolyzer","text":"The efficiency penalty is calculated as:","category":"page"},{"location":"nodes/electrolyzer/","page":"Electrolyzer","title":"Electrolyzer","text":"beginaligned\ntextttelect_efficiency_penaltyn_el t =  \n1 - degradation_rate(n_el)  100 times textttelect_prev_usen_el t\nendaligned","category":"page"},{"location":"nodes/electrolyzer/","page":"Electrolyzer","title":"Electrolyzer","text":"It corresponds to a linear degradation depending on how much the electrolzer is utilized. The division by 100 is necessary as the rate is defined as percentage value.","category":"page"},{"location":"nodes/electrolyzer/","page":"Electrolyzer","title":"Electrolyzer","text":"The fixed operating expenses include the stack replacement:","category":"page"},{"location":"nodes/electrolyzer/","page":"Electrolyzer","title":"Electrolyzer","text":"beginaligned\ntextttopex_fixedn_el t_inv =  \nopex_fixed(n_el t_inv) times textttcap_instn_el first(t_inv) +  \ntextttelect_stack_replace_bn_el t_inv times capacityn_el t_inv times   stack_replacement_cost(n_el t_inv)  duration_strat(t_inv)\nendaligned","category":"page"},{"location":"nodes/electrolyzer/","page":"Electrolyzer","title":"Electrolyzer","text":"tip: Why do we use `first()`\nThe variables textttcap_inst are declared over all operational periods (see the section on Capacity variables for further explanations). Hence, we use the function first(t_inv) to retrieve the installed capacities in the first operational period of a given investment period t_inv.","category":"page"},{"location":"nodes/electrolyzer/","page":"Electrolyzer","title":"Electrolyzer","text":"There are two contributors to the fixed operating expenses,","category":"page"},{"location":"nodes/electrolyzer/","page":"Electrolyzer","title":"Electrolyzer","text":"the standed fixed operating expenses and\nthe cost for stack replacement.","category":"page"},{"location":"nodes/electrolyzer/","page":"Electrolyzer","title":"Electrolyzer","text":"The first contributions is similar to the standard function to the function constraints_opex_fixed.","category":"page"},{"location":"nodes/electrolyzer/","page":"Electrolyzer","title":"Electrolyzer","text":"The second contribution corresponds to the cost of stack replacement. The overall contribution is divided by the value of the function duration_strat(t_inv) as the variable textttopex_fixedn_el t_inv is multiplied with the same value in the objective function. As you only have to pay once for stack replacement, irrespectively of the length of an investment period, it is necessary to include this division.","category":"page"},{"location":"nodes/electrolyzer/","page":"Electrolyzer","title":"Electrolyzer","text":"In the case of investment potential in the node, the stack replacement cost is reformulated as:","category":"page"},{"location":"nodes/electrolyzer/","page":"Electrolyzer","title":"Electrolyzer","text":"beginaligned\ntextttopex_fixedn_el t_inv =  \nopex_fixed(n_el t_inv) times textttcap_instn_el first(t_inv) +  \ntextttelect_stack_replace_bn_el t_inv times textttcap_currentn_el t_inv times  stack_replacement_cost(n_el t_inv)  duration_strat(t_inv)\nendaligned","category":"page"},{"location":"nodes/electrolyzer/","page":"Electrolyzer","title":"Electrolyzer","text":"resulting in a bilinear term of a binary and continuous variable. As outlined above, this bilinear term can be reformulated as linear problem, see Linear reformulation. The implementation uses the function EnergyModesHydrogen.multiplication_variables() for determining which approach should be chosen.","category":"page"},{"location":"nodes/electrolyzer/#nodes-elec-math-con-add-use","page":"Electrolyzer","title":"Electrolyzer use constraints","text":"","category":"section"},{"location":"nodes/electrolyzer/","page":"Electrolyzer","title":"Electrolyzer","text":"The calculation of the previous usage of the electrolyzer node requires the definition of new constraint functions as the approach differs depending on the chosen TimeStructure. The overall approach is similar to the calculation of the level constraints in EnergyModelsBase. This is achieved through the function constraints_usage() and the individual functions calculated from the function.","category":"page"},{"location":"nodes/electrolyzer/","page":"Electrolyzer","title":"Electrolyzer","text":"Within this function, we first calculate forall t_inv 1 in T^Inv t_inv 2 in T^Inv the linear reformulation of the product","category":"page"},{"location":"nodes/electrolyzer/","page":"Electrolyzer","title":"Electrolyzer","text":"First, the usage in each investment period t_inv is calculated:","category":"page"},{"location":"nodes/electrolyzer/","page":"Electrolyzer","title":"Electrolyzer","text":"textttelect_use_spn_el t_inv times 1000 = sum_t in t_invtextttelect_on_bn_el t\ntimes scale_op_sp(t_inv t)","category":"page"},{"location":"nodes/electrolyzer/","page":"Electrolyzer","title":"Electrolyzer","text":"The previous usage up the current investment period t_inv is calculated through the function constraints_usage_sp. In the first investment period, the previous usage is fixed to a value of 0:","category":"page"},{"location":"nodes/electrolyzer/","page":"Electrolyzer","title":"Electrolyzer","text":"textttelect_prev_use_spn_el t_inv = 0","category":"page"},{"location":"nodes/electrolyzer/","page":"Electrolyzer","title":"Electrolyzer","text":"while the implementation within subsequent investment periods require considering potential stack replacement. This is achieved through introducing the auxiliary variable textttaux_var given by","category":"page"},{"location":"nodes/electrolyzer/","page":"Electrolyzer","title":"Electrolyzer","text":"beginaligned\ntextttaux_varn_el t_inv =  \n  textttelect_prev_use_spn_el t_invprev +  \n  textttelect_use_spn_el t_invprev times duration_strat(t_invprev) \nendaligned","category":"page"},{"location":"nodes/electrolyzer/","page":"Electrolyzer","title":"Electrolyzer","text":"The previous usage in the subsequent investment periods is then given by","category":"page"},{"location":"nodes/electrolyzer/","page":"Electrolyzer","title":"Electrolyzer","text":"beginaligned\ntextttelect_prev_use_spn_el t_inv =  \n  textttaux_varn_el t_inv times (1-textttelect_stack_replace_bn_el t_inv) \nendaligned","category":"page"},{"location":"nodes/electrolyzer/","page":"Electrolyzer","title":"Electrolyzer","text":"using a direct implememtation of the linear reformulation explained in the section linear reformulation","category":"page"},{"location":"nodes/electrolyzer/","page":"Electrolyzer","title":"Electrolyzer","text":"beginaligned\ntextttelect_prev_use_spn_el t_inv geq 0 \n\ntextttelect_prev_use_spn_el t_inv geq  \n  ub(t_inv) times ((1-textttelect_stack_replace_bn_el t_inv) - 1) +  \n  textttaux_varn_el t_inv \n\ntextttelect_prev_use_spn_el t_inv leq  \n  ub(t_inv) times (1-textttelect_stack_replace_bn_el t_inv) \n\ntextttelect_prev_use_spn_el t_inv leq textttaux_varn_el t_inv \nendaligned","category":"page"},{"location":"nodes/electrolyzer/","page":"Electrolyzer","title":"Electrolyzer","text":"in which the upper bound ub is either the installed capacity or the maximum installed capacity, depending on whether the electrolyzer includes investments, or not. These constraints enforce that if stack replacement occurs, that is textttelect_stack_replace_b = 1, textttelect_prev_use_sp is reset to a value of 0.","category":"page"},{"location":"nodes/electrolyzer/","page":"Electrolyzer","title":"Electrolyzer","text":"If the TimeStructure includes representative periods, then the usage in each representative period t_rp is calculated (in the function constraints_usage_sp_iterate):","category":"page"},{"location":"nodes/electrolyzer/","page":"Electrolyzer","title":"Electrolyzer","text":"textttelect_use_rpn_el t_rp times 1000 = sum_t in t_rptextttelect_on_bn_el t\ntimes scale_op_sp(t_inv t)","category":"page"},{"location":"nodes/electrolyzer/","page":"Electrolyzer","title":"Electrolyzer","text":"In addition, if we are in the last operational period (of the last representative period) of an investment period, we calculate (for each operational scenario) the constraint","category":"page"},{"location":"nodes/electrolyzer/","page":"Electrolyzer","title":"Electrolyzer","text":"beginaligned\nstack_lifetime(n) geq  \ntextttelect_prev_usen_el t times 1000 +  \ntextttelect_use_spn_el t_inv times (duration_strat(t_inv) - 1) times 1000 + \n textttelect_on_bn_el t times scale_op_sp(t_inv t)\nendaligned","category":"page"},{"location":"nodes/electrolyzer/","page":"Electrolyzer","title":"Electrolyzer","text":"to avoid a violation of the lifetime constraint. This constraint is only necessary for the last operational period as stack replacement is only allowed at the beginning of an investment period.","category":"page"},{"location":"nodes/electrolyzer/","page":"Electrolyzer","title":"Electrolyzer","text":"The declaration of the actual constraint for the previous usage can be differentiated in four individual cases:","category":"page"},{"location":"nodes/electrolyzer/","page":"Electrolyzer","title":"Electrolyzer","text":"In the first operational period (in the first representative period) in the first investment period:\nThe variable textttelect_prev_use is fixed to 0.\nIn the first operational period (in the first representative period) in subsquent investment periods:\nThe constraint is given as\ntextttelect_previous_usen_el t = textttelect_prev_use_spn_el t_inv\nIn the first operational period in subsequent representative period:\nThe constraint is given as\nbeginaligned\ntextttelect_textttprevious_usen_el t =  \ntextttelect_prev_usen_el first(t_rpprev) +\ntextttelect_use_rpn_el t_rpprev\nendaligned\nwith t_rpprev denoting the previous representative period.\nIn all other operational periods\nbeginaligned\ntextttelect_textttprevious_usen_el t =  \ntextttelect_prev_usen_el t_prev +\nduration(t_prev) times textttelect_on_bn t_prev1000\nendaligned\nwith t_prev denoting the previous operational period.","category":"page"},{"location":"manual/simple-example/#man-exampl","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"manual/simple-example/","page":"Examples","title":"Examples","text":"For the content of the example, see the examples directory in the project repository.","category":"page"},{"location":"manual/simple-example/","page":"Examples","title":"Examples","text":"note: Solver\nIf you use windows, you must have installed the binaries of the solver in addition. This is explained on the quick start page.","category":"page"},{"location":"manual/simple-example/#The-package-is-installed-with-]-add","page":"Examples","title":"The package is installed with ] add","text":"","category":"section"},{"location":"manual/simple-example/","page":"Examples","title":"Examples","text":"From the Julia REPL, run","category":"page"},{"location":"manual/simple-example/","page":"Examples","title":"Examples","text":"# Starts the Julia REPL\njulia> using EnergyModelsHydrogen\n# Get the path of the examples directory\njulia> exdir = joinpath(pkgdir(EnergyModelsHydrogen), \"examples\")\n# Include the code into the Julia REPL to run the electrolyzer node example\njulia> include(joinpath(exdir, \"electrolyzer.jl\"))\n# Include the code into the Julia REPL to run the reformer node example\njulia> include(joinpath(exdir, \"reformer.jl\"))\n# Include the code into the Julia REPL to run the H2 storage ndoe example\njulia> include(joinpath(exdir, \"h2_storage.jl\"))","category":"page"},{"location":"manual/simple-example/#The-code-was-downloaded-with-git-clone","page":"Examples","title":"The code was downloaded with git clone","text":"","category":"section"},{"location":"manual/simple-example/","page":"Examples","title":"Examples","text":"The examples can then be run from the terminal with","category":"page"},{"location":"manual/simple-example/","page":"Examples","title":"Examples","text":"/path/to/EnergyModelsHydrogen.jl/examples $ julia electrolyzer.jl\n/path/to/EnergyModelsHydrogen.jl/examples $ julia reformer.jl\n/path/to/EnergyModelsHydrogen.jl/examples $ julia h2_storage.jl","category":"page"},{"location":"nodes/reformer/#nodes-ref","page":"Reformer","title":"Reformer node","text":"","category":"section"},{"location":"nodes/reformer/","page":"Reformer","title":"Reformer","text":"Reformer plants are in general large chemical production facilities as they experience significant economies of scale. Utilizing standard modelling approaches would hence result in an overestimation of the flexibility and operating windows of the plants. They can be characterized by:","category":"page"},{"location":"nodes/reformer/","page":"Reformer","title":"Reformer","text":"a slow change in their operating point due to both heat and mass integration within the process,\na minimum operating point under which they cannot operate,\nsignificant time requirements for both start-up and shutdown with corresponding costs due to integration of the processes, and\na minimum down time once turned off.","category":"page"},{"location":"nodes/reformer/","page":"Reformer","title":"Reformer","text":"In this respect, reformer plants should be represented with unit commitment constraints with 4 distinctive states, startup, online, shutdown, and offline.","category":"page"},{"location":"nodes/reformer/#nodes-ref-fields","page":"Reformer","title":"Introduced type and its field","text":"","category":"section"},{"location":"nodes/reformer/","page":"Reformer","title":"Reformer","text":"Reformer are incorporated through a single composite type Reformer although provisions are made to include other types. The following sections will provide you with an explanation of the individual fields of the type.","category":"page"},{"location":"nodes/reformer/","page":"Reformer","title":"Reformer","text":"danger: Reformer with changing capacities\nThe unit commitment, minimum usage, and rate of change constraints are for the installed capacity. This implies that if you include changing capacities over the course of time or if you include investments, it is required to include a separate node for each investment period with a changing capacity.","category":"page"},{"location":"nodes/reformer/#nodes-ref-fields-stand","page":"Reformer","title":"Standard fields","text":"","category":"section"},{"location":"nodes/reformer/","page":"Reformer","title":"Reformer","text":"The standard fields are given as:","category":"page"},{"location":"nodes/reformer/","page":"Reformer","title":"Reformer","text":"id:\nThe field id is only used for providing a name to the node. This is similar to the approach utilized in EnergyModelsBase.\ncap::TimeProfile:\nThe installed capacity corresponds to the potential usage of the node. The capacity does not have to correspond to the amount of hydrogen produced. Instead, it is relative to the specified input and output ratios. However, capacities of reformer are in general specified based on the produced hydrogen.\nIf the node should contain investments through the application of EnergyModelsInvestments, it is important to note that you can only use FixedProfile or StrategicProfile for the capacity, but not RepresentativeProfile or OperationalProfile. In addition, all values have to be non-negative.\nopex_var::TimeProfile:\nThe variable operational expenses are based on the capacity utilization through the variable :cap_use. Hence, it is directly related to the specified input and output ratios. The variable operating expenses can be provided as OperationalProfile as well.\nopex_fixed::TimeProfile:\nThe fixed operating expenses are relative to the installed capacity (through the field cap) and the chosen duration of an investment period as outlined on Utilize TimeStruct.\nIt is important to note that you can only use FixedProfile or StrategicProfile for the fixed OPEX, but not RepresentativeProfile or OperationalProfile. In addition, all values have to be non-negative.\ninput::Dict{<:Resource, <:Real} and output::Dict{<:Resource, <:Real}:\nBoth fields describe the input and output Resources with their corresponding conversion factors as dictionaries. In the case of a reformer, input should include natural gas and potentially water and electricity while the output is hydrogen and potentially heat, if included in the model, and electricity. Whether electricity is an input or output is depending on the process design for the reformer.\nAll values have to be non-negative.\ndata::Vector{Data}:\nAn entry for providing additional data to the model. In the current state of electrolysis, it is only relevant for additional investment data when EnergyModelsInvestments is used.","category":"page"},{"location":"nodes/reformer/","page":"Reformer","title":"Reformer","text":"warning: CO₂ as output\nIf you include CO₂ capture through the application of CaptureData (explained on the page Data functions), you have to add your CO₂ instance as output to the dictionary. The chosen value is not important, as the CO₂ outlet flow is calculated based on the CO₂ intensity of the fuel and the chosen capture rate.","category":"page"},{"location":"nodes/reformer/#nodes-ref-fields-new","page":"Reformer","title":"Additional fields","text":"","category":"section"},{"location":"nodes/reformer/","page":"Reformer","title":"Reformer","text":"load_limits::LoadLimits:\nThe load_limits specify the lower and upper limit for operating the reformer plant. These limits are included through the type LoadLimits and correspond to a fraction of the installed capacity as described in Limiting the load.\nThe lower limit has to be non-negative while the upper limit has to be higher than the lower limit.\nstartup::CommitParameters, shutdown::CommitParameters, and offline::CommitParameters:\nThe fields startup, shutdown, and offline specify the required parameters for unit commitment. These parameters are included through the type CommitParameters and correspond to both a stage cost and minium time in a stage as described in Unit commitment.\nIt is important to note that you can only use FixedProfile, StrategicProfile, or RepresentativeProfile for the time profiles, but not OperationalProfile. In addition, all values have to be non-negative.\nrate_limit::TimeProfile:\nThe rate_limit specifies the maximum allowed change in the relative capacity utilization of the reformer in a duration of 1 of an operational period as outlined on Utilize TimeStruct. Different types can be incorporated having constraints on the positive (RampUp and RampBi) or negative (RampDown and RampBi) allowed change as described in Change of utilization. Constraints are only created when required by the composite type.\nAll values have to be in range 01.","category":"page"},{"location":"nodes/reformer/#nodes-ref-math","page":"Reformer","title":"Mathematical description","text":"","category":"section"},{"location":"nodes/reformer/","page":"Reformer","title":"Reformer","text":"In the following mathematical equations, we use the name for variables and functions used in the model. Variables are in general represented as","category":"page"},{"location":"nodes/reformer/","page":"Reformer","title":"Reformer","text":"textttvar_exampleindex_1 index_2","category":"page"},{"location":"nodes/reformer/","page":"Reformer","title":"Reformer","text":"with square brackets, while functions are represented as","category":"page"},{"location":"nodes/reformer/","page":"Reformer","title":"Reformer","text":"func_example(index_1 index_2)","category":"page"},{"location":"nodes/reformer/","page":"Reformer","title":"Reformer","text":"with paranthesis.","category":"page"},{"location":"nodes/reformer/#nodes-ref-math-var","page":"Reformer","title":"Variables","text":"","category":"section"},{"location":"nodes/reformer/#nodes-ref-math-var-stand","page":"Reformer","title":"Standard variables","text":"","category":"section"},{"location":"nodes/reformer/","page":"Reformer","title":"Reformer","text":"The reformer node types utilize all standard variables from the RefNetworkNode, as described on the page Optimization variables. The variables include:","category":"page"},{"location":"nodes/reformer/","page":"Reformer","title":"Reformer","text":"textttopex_var\ntextttopex_fixed\ntextttcap_use\ntextttcap_inst\ntextttflow_in\ntextttflow_out","category":"page"},{"location":"nodes/reformer/#nodes-ref-math-add","page":"Reformer","title":"Additional variables","text":"","category":"section"},{"location":"nodes/reformer/","page":"Reformer","title":"Reformer","text":"Reformer nodes declare in addition several variables through dispatching on the method EnergyModelsBase.variables_node() for including the unit commitment constraints. These variables are for reformer node n_ref in operational period t:","category":"page"},{"location":"nodes/reformer/","page":"Reformer","title":"Reformer","text":"textttref_off_bn_ref t: Offline indicator,\ntextttref_start_bn_ref t: Startup indicator,\ntextttref_on_bn_ref t: Online indicator, and\ntextttref_shut_bn_ref t: Shutdown indicator.","category":"page"},{"location":"nodes/reformer/","page":"Reformer","title":"Reformer","text":"These variables are binary variables which indicate in which state the reformer is operating. A value of 1 corresponds to an operation in the given stage while a value of 0 implies that the reformer is not operating in a different state","category":"page"},{"location":"nodes/reformer/#nodes-ref-math-con","page":"Reformer","title":"Constraints","text":"","category":"section"},{"location":"nodes/reformer/","page":"Reformer","title":"Reformer","text":"The following sections omit the direction inclusion of the vector of reformer nodes. Instead, it is implicitly assumed that the constraints are valid forall n_ref  N^Ref for all Reformer types if not stated differently. In addition, all constraints are valid forall t in T (that is in all operational periods) or forall t_inv in T^Inv (that is in all investment periods).","category":"page"},{"location":"nodes/reformer/#nodes-ref-math-con-stand","page":"Reformer","title":"Standard constraints","text":"","category":"section"},{"location":"nodes/reformer/","page":"Reformer","title":"Reformer","text":"Reformer nodes utilize only a small set of the standard constraints described on Constraint functions. These standard constraints are:","category":"page"},{"location":"nodes/reformer/","page":"Reformer","title":"Reformer","text":"constraints_capacity_installed:\ntextttcap_instn_ref t = capacity(n_ref t)\ntip: Using investments\nThe function constraints_capacity_installed is also used in EnergyModelsInvestments to incorporate the potential for investment. Nodes with investments are then no longer constrained by the parameter capacity.\nconstraints_flow_in:\ntextttflow_inn_ref t p = inputs(n_ref p) times textttcap_usen_ref t\nqquad forall p in inputs(n_ref)\nconstraints_flow_out:\ntextttflow_outn_ref t p =\noutputs(n_ref p) times textttcap_usen_ref t\nqquad forall p in outputs(n_ref) setminus textCO_2\nconstraints_opex_fixed:\ntextttopex_fixedn_ref t_inv = opex_fixed(n_ref t_inv) times textttcap_instn_ref first(t_inv)\ntip: Why do we use `first()`\nThe variables textttstor_level_inst are declared over all operational periods (see the section on Capacity variables for further explanations). Hence, we use the function first(t_inv) to retrieve the installed capacities in the first operational period of a given investment period t_inv in the function constraints_opex_fixed.\nconstraints_data:\nThis function is only called for specified data of the reformer, see above.","category":"page"},{"location":"nodes/reformer/","page":"Reformer","title":"Reformer","text":"The function constraints_capacity_installed is also used in EnergyModelsInvestments to incorporate the potential for investment. Nodes with investments are then no longer constrained by the parameter capacity.","category":"page"},{"location":"nodes/reformer/","page":"Reformer","title":"Reformer","text":"The variable textttcap_inst is declared over all operational periods (see the section on Capacity variables for further explanations). Hence, we use the function first(t_inv) to retrieve the installed capacity in the first operational period of a given investment period t_inv in the function constraints_opex_fixed.","category":"page"},{"location":"nodes/reformer/","page":"Reformer","title":"Reformer","text":"The function constraints_capacity is extended with a new method for reformer nodes to account for the minimum and maximum load:","category":"page"},{"location":"nodes/reformer/","page":"Reformer","title":"Reformer","text":"beginaligned\ntextttcap_usen_ref t  geq\nmin_load(n_ref t) times textttref_on_bn_ref t times capacity(n_ref t) \ntextttcap_usen_ref t  leq\nmax_load(n_ref t) times textttref_on_bn_ref t times capacity(n_ref t)\nendaligned","category":"page"},{"location":"nodes/reformer/","page":"Reformer","title":"Reformer","text":"In the case of investment potential in the node, this constraint is reformulated as:","category":"page"},{"location":"nodes/reformer/","page":"Reformer","title":"Reformer","text":"beginaligned\ntextttcap_usen_ref t  geq\nmin_load(n_ref t) times textttref_on_bn_ref t times textttcap_instn_ref t \ntextttcap_usen_ref t  leq\nmax_load(n_ref t) times textttref_on_bn_ref t times textttcap_instn_ref t\nendaligned","category":"page"},{"location":"nodes/reformer/","page":"Reformer","title":"Reformer","text":"resulting in a bilinear term of a binary and continuous variable.","category":"page"},{"location":"nodes/reformer/","page":"Reformer","title":"Reformer","text":"tip: Handling of bilinearities\nBilinearities of this type can be reformulated as linear problem through an auxiliary variable. EnergyModelsHydrogen provides a linear reformulation through the function EnergyModelsHydrogen.linear_reformulation. The linear reformulation is also explained in Linear reformulation. textttcap_instn_ref t is replaced with capacity(n_ref t) if the node does not have the potential for investments. The implementation uses the function EnergyModelsHydrogen.multiplication_variables for determining which approach should be chosen.The function multiplication_variables is only called once for each bilinearity to avoid creating the auxiliary variable multiple times.","category":"page"},{"location":"nodes/reformer/","page":"Reformer","title":"Reformer","text":"The function constraints_opex_var is extended with a new method for a reformer node to account for the costs associated to be within a given state:","category":"page"},{"location":"nodes/reformer/","page":"Reformer","title":"Reformer","text":"beginaligned\ntextttopex_varn_ref t = sum_t in t_inv (  \nopex_var(n_ref t) times textttcap_instn_ref t +  \nopex_startup(n_ref t) times textttcap_instn_ref t times textttref_start_bn_ref t +  \nopex_shutdown_(n_ref t) times textttcap_instn_ref t times textttref_shut_bn_ref t +  \nopex_off(n_ref t) times textttcap_instn_ref t times textttref_off_bn_ref t  \n) times scale_op_sp(t_inv t)\nendaligned","category":"page"},{"location":"nodes/reformer/","page":"Reformer","title":"Reformer","text":"tip: The function `scale_op_sp`\nThe function scale_op_sp(t_inv t) calculates the scaling factor between operational and investment periods. It also takes into account potential operational scenarios and their probability as well as representative periods.","category":"page"},{"location":"nodes/reformer/","page":"Reformer","title":"Reformer","text":"The linear reformulation is also explained in Linear reformulation, as explained previously. Similarly, textttcap_instn_ref t is replaced with capacity(n_ref t) if the node does not have the potential for investments.","category":"page"},{"location":"nodes/reformer/#nodes-ref-math-con-add","page":"Reformer","title":"Additional constraints","text":"","category":"section"},{"location":"nodes/reformer/#nodes-ref-math-con-add-node","page":"Reformer","title":"Constraints calculated in create_node","text":"","category":"section"},{"location":"nodes/reformer/","page":"Reformer","title":"Reformer","text":"A reformer node can only be in a single stage in a given operational period t. This is enforced through a single constraint given as","category":"page"},{"location":"nodes/reformer/","page":"Reformer","title":"Reformer","text":"textttref_off_bn_ref t + textttref_start_bn_ref t + textttref_on_bn_ref t + textttref_shut_bn_ref t = 1","category":"page"},{"location":"nodes/reformer/#nodes-ref-math-con-add-fun","page":"Reformer","title":"Constraints through separate functions","text":"","category":"section"},{"location":"nodes/reformer/","page":"Reformer","title":"Reformer","text":"Within the function create_node, we iterate the through the investment periods to call three functions, EnergyModelsHydrogen.constraints_rate_of_change_iterate for enforcing the limit on the rate of change, EnergyModelsHydrogen.constraints_state_seq_iter for enforcing the correct sequencing of the individual states, and EnergyModelsHydrogen.constraints_state_time_iter for enforcing the minimum time a node has to be in a given state. All functions iterate through the individual time structures (investment periods, representative periods, operational scenarios) to calculate the proper constraints based on the chosen time structure. All functions utilize a cyclic approach in which the last operational period t_last within an investment period (representative period, if included, or operational scenario, if included) is required to be passed to the constraint.","category":"page"},{"location":"nodes/reformer/","page":"Reformer","title":"Reformer","text":"As outlined, the function constraints_rate_of_change_iterate iterates through the time structure to determine the correct last operational period. Both the previous, the current, and the last operational periods are then passed to a instance of the parametric type  EnergyModelsHydrogen.RefPeriods which allows to either extract the last or previous period using the function  EnergyModelsHydrogen.prev_op, depending on whether the previous period t_prev is nothing. The general approach for a rate of change constraint is given by","category":"page"},{"location":"nodes/reformer/","page":"Reformer","title":"Reformer","text":"beginaligned\ntextttcap_usen_ref t - textttref_on_bn_ref t_prev  leq textttcap_instn t times ramp_up(n_ref t) times duration(t) \ntextttcap_usen_ref t_prev - textttref_on_bn_ref t  leq textttcap_instn t times ramp_down(n_ref t) times duration(t)\nendaligned","category":"page"},{"location":"nodes/reformer/","page":"Reformer","title":"Reformer","text":"Both constraints have to be included to limit the rate of change both if the capacity utilization is increasing and decreasing. The reformer node should also be allowed to go from the state startup to any capacity utilization as well as from any capacity utilization to the state shutdown. This implies that the constraints should only be active, if textttref_on_bn_ref t = textttref_on_bn_ref t_prev = 1 corresponding to a disjunction.","category":"page"},{"location":"nodes/reformer/","page":"Reformer","title":"Reformer","text":"This is achieved through rewriting the rate of change constraints using the convex-hull reformulation (which is similar to the Big-M reformulation in this specific instance):","category":"page"},{"location":"nodes/reformer/","page":"Reformer","title":"Reformer","text":"beginaligned\ntextttcap_usen_ref t -  textttref_on_bn_ref t_prev leq  \ntextttcap_instn t times ramp_up(n_ref t) * duration(t) +  \ncapacity(n_ref t) times (2 - textttref_on_bn_ref t - textttref_on_bn_ref t_prev)\nendaligned","category":"page"},{"location":"nodes/reformer/","page":"Reformer","title":"Reformer","text":"tip: How does it work?\nWe can differentiate the constraint into three different cases:Consider the case in which textttref_on_bn_ref t = textttref_on_bn_ref t_prev = 1. The second term cancels out in this situation resulting in the original rate of change constraints.\nIf textttref_on_bn_ref t neq textttref_on_bn_ref t_prev we experience a change in state. In this situation, it should be possible to move from 100 % capacity utilization to 0 % or vice versa. This is allowed as the second term corresponds to capacity(n t).\nIf textttref_on_bn_ref t = textttref_on_bn_ref t_prev = 0, this constraint is no longer relevant as the capacity utilization is already limited in other constraints. It would however be possible, if not restricted by other constraints, to increase the utilization from 0 to 100 % in a single operational period.","category":"page"},{"location":"nodes/reformer/","page":"Reformer","title":"Reformer","text":"The function capacity of the node is replaced with the function max_installed(investment_data()) If you utilize EnergyModelsInvestments and the reformer node has the potential for investment.","category":"page"},{"location":"nodes/reformer/","page":"Reformer","title":"Reformer","text":"The function constraints_state_seq_iter utlizes the same iteration approach as the function constraints_rate_of_change_iterate. The constraint is eventually included through the function EnergyModelsHydrogen.constraints_state_seq in which the sequencing constraints are included:","category":"page"},{"location":"nodes/reformer/","page":"Reformer","title":"Reformer","text":"beginaligned\ntextttref_off_bn_ref t_prev  geq textttref_start_bn_ref t - textttref_start_bn_ref t_prev \ntextttref_start_bn_ref t_prev  geq textttref_on_bn_ref t - textttref_on_bn_ref t_prev \ntextttref_on_bn_ref t_prev  geq textttref_shut_bn_ref t - textttref_shut_bn_ref t_prev \ntextttref_shut_bn_ref t_prev  geq textttref_off_bn_ref t - textttref_off_bn_ref t_prev \nendaligned","category":"page"},{"location":"nodes/reformer/","page":"Reformer","title":"Reformer","text":"If the previous period t_prev is nothing, it is replaced by t_last.","category":"page"},{"location":"nodes/reformer/","page":"Reformer","title":"Reformer","text":"tip: How does it work?\nConsider a case in which the former was in the  previous period t_prev offline. In this situation, we wil;l have textttref_off_bn_ref t_prev = 1 while textttref_start_bn_ref t_prev = 0, textttref_on_bn_ref t_prev = 0, and textttref_shut_bn_ref t_prev = 0.Constraint 1 implies that textttref_start_bn_ref t can be either 0 or 1.\nConstraints 2 and 3 enforce that both textttref_on_bn_ref t and textttref_shut_bn_ref t are 0 as the left hand side is 0.\nConstraint 4 implies textttref_off_bn_ref t can be either 0 or 1.As a consequence, we can either remain in the state offline or proceed to the state startup.","category":"page"},{"location":"nodes/reformer/","page":"Reformer","title":"Reformer","text":"The function constraints_state_time_iter utlizes the same iteration approach as the function constraints_state_seq_iter. However, we calculate the the constraints within the function when the operatioanl time structure is given as SimpleTimes. The implementation can utilize different lengths within each state as well as variations in the duration of operational periods. This is achieved through the function TimeStruct.chunk_duration which provides an iterator of time chuncks of at least a given duration.","category":"page"},{"location":"nodes/reformer/","page":"Reformer","title":"Reformer","text":"The constraints are cyclic constraints which utilize the function zip to obtain a combined iterator of the individual chunk_duration iterators and the current operational period.","category":"page"},{"location":"nodes/reformer/","page":"Reformer","title":"Reformer","text":"This approach is best explained with an example in which we want to force the model to be at least time_startup in the startup state: Consider an operational period t, its previous operator t_prev, and the chunck t_next start which corresponds to an iterator for the next n operational periods so that the duration of the iterator including the operational period t is at least as large as the provided value time_startup.","category":"page"},{"location":"nodes/reformer/","page":"Reformer","title":"Reformer","text":"The constraint is then given as","category":"page"},{"location":"nodes/reformer/","page":"Reformer","title":"Reformer","text":"beginaligned\nsum_theta in t_next start textttref_start_bm_ref theta geq  \ntime_startup(n_ref t) times (textttref_start_bm_ref t-textttref_start_bm_ref t_prev)\nendaligned","category":"page"},{"location":"nodes/reformer/","page":"Reformer","title":"Reformer","text":"It enforces in the case of a state change from 0 to 1 between the previous periods t_prev and the current period t that the periods following t up to a total duration of time_startup are also 1.","category":"page"},{"location":"library/internals/methods-EMH/#lib-int-met","page":"Methods - Internal","title":"Methods - Internal","text":"","category":"section"},{"location":"library/internals/methods-EMH/#lib-int-met-idx","page":"Methods - Internal","title":"Index","text":"","category":"section"},{"location":"library/internals/methods-EMH/","page":"Methods - Internal","title":"Methods - Internal","text":"Pages = [\"methods-EMH.md\"]","category":"page"},{"location":"library/internals/methods-EMH/#lib-int-met-con","page":"Methods - Internal","title":"Constraint methods","text":"","category":"section"},{"location":"library/internals/methods-EMH/","page":"Methods - Internal","title":"Methods - Internal","text":"EnergyModelsHydrogen.constraints_usage\nEnergyModelsHydrogen.constraints_usage_sp\nEnergyModelsHydrogen.constraints_usage_iterate\nEnergyModelsHydrogen.constraints_previous_usage\nEnergyModelsHydrogen.constraints_rate_of_change_iterate\nEnergyModelsHydrogen.constraints_rate_of_change\nEnergyModelsHydrogen.constraints_state_seq_iter\nEnergyModelsHydrogen.constraints_state_seq\nEnergyModelsHydrogen.constraints_state_time_iter","category":"page"},{"location":"library/internals/methods-EMH/#EnergyModelsHydrogen.constraints_usage","page":"Methods - Internal","title":"EnergyModelsHydrogen.constraints_usage","text":"constraints_usage(m, n::AbstractElectrolyzer, 𝒯ᴵⁿᵛ, modeltype::EnergyModel)\n\nFunction for creating the usage constraints for an AbstractElectrolyzer. These constraints calculate the usage of the electrolyzer up to each time step for both the lifetime and the degradation calculations.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-EMH/#EnergyModelsHydrogen.constraints_usage_sp","page":"Methods - Internal","title":"EnergyModelsHydrogen.constraints_usage_sp","text":"constraints_usage_sp(\n    m,\n    n::AbstractElectrolyzer,\n    prev_pers::PreviousPeriods,\n    t_inv::TS.AbstractStrategicPeriod,\n    modeltype::EnergyModel,\n)\n\nFunction for creating the constraints on the previous usage of an AbstractElectrolyzer before the beginning of a strategic period.\n\nIn the case of the first strategic period, it fixes the variable elect_prev_use_sp to 0. In all subsequent strategic periods, the previous usage is calculated.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-EMH/#EnergyModelsHydrogen.constraints_usage_iterate","page":"Methods - Internal","title":"EnergyModelsHydrogen.constraints_usage_iterate","text":"constraints_usage_iterate(\n    m,\n    n::AbstractElectrolyzer,\n    prev_pers::PreviousPeriods,\n    elec_pers::ElecPeriods,\n    per,\n    ts::RepresentativePeriods,\n    modeltype::EnergyModel,\n)\n\nIterate through the individual time structures of a AbstractElectrolyzer node.\n\nIn the case of RepresentativePeriods, additional constraints are calculated for the usage of the electrolyzer in representative periods through introducing the variable elect_use_rp[𝒩ᴱᴸ, 𝒯ʳᵖ].\n\n\n\n\n\nIn the case of OperationalScenarios, we purely iterate through the individual time structures.\n\n\n\n\n\nIn the case of SimpleTimes, the iterator function is at its lowest level. In this situation,the previous level is calculated using the function constraints_previous_usage. The approach for calculating the constraints is depending on the types in the parameteric type PreviousPeriods.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-EMH/#EnergyModelsHydrogen.constraints_previous_usage","page":"Methods - Internal","title":"EnergyModelsHydrogen.constraints_previous_usage","text":"constraints_previous_usage(\n    m,\n    n::AbstractElectrolyzer,\n    prev_pers::PreviousPeriods,\n    elec_pers::ElecPeriods,\n    t::OperationalPeriod,\n    modeltype::EnergyModel,\n)\n\nReturns the previous usage of an AbstractElectrolyzer node depending on the type of PreviousPeriods.\n\nThe basic functionality is used in the case when the previous operational period is a TimePeriod, in which case it just returns the previous operational period.\n\n\n\n\n\nWhen the previous operational, representative, and strategic periods are Nothing, the\n\nvariable elect_prev_use is fixed to a value of 0.\n\n\n\n\n\nWhen the previous operational and representative periods are Nothing while the previous strategic period is given, then previous usage is given through the sum of the usage in all previous strategic periods after the stack replacement through the variable prev_usage.\n\n\n\n\n\nWhen the previous operational period is Nothing and the previous representative period an AbstractRepresentativePeriod then the time structure does include RepresentativePeriods.\n\nThe constraint then sums up the values from the previous representative period.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-EMH/#EnergyModelsHydrogen.constraints_rate_of_change_iterate","page":"Methods - Internal","title":"EnergyModelsHydrogen.constraints_rate_of_change_iterate","text":"constraints_rate_of_change_iterate(\n    m,\n    n::Reformer,\n    per,\n    t_last,\n    ts,\n    modeltype::EnergyModel,\n)\n\nFunction for iterating through the time structure for calculating the correct rate of change constraints of the Reformer n.\n\nWhen the time structure includes RepresentativePeriods, period t_last is updated with last operational period within each representative period.\n\n\n\n\n\nWhen the time structure includes OperationalScenarios, period t_last is updated with last operational period within each operational scenario.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-EMH/#EnergyModelsHydrogen.constraints_rate_of_change","page":"Methods - Internal","title":"EnergyModelsHydrogen.constraints_rate_of_change","text":"constraints_rate_of_change(\n    m,\n    n::Reformer,\n    ramp_lim::UnionRampUp,\n    ref_pers::RefPeriods,\n    prod_on,\n    modeltype::EnergyModel,\n)\n\nFunction for creating the constraints on the maximum postivite rate of change. This constraint is only active if the Reformer is online in both the current and the previous operational periods, that is:\n\nm[:ref_on_b][n, t_prev] = m[:ref_on_b][n, t] = 1\n\nThe function prev_op is used to incorporate the cyclic constraints while the function ramp_disjunct is used to extract the disjuntion contribution to the constraint depending on the modeltype.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-EMH/#EnergyModelsHydrogen.constraints_state_seq_iter","page":"Methods - Internal","title":"EnergyModelsHydrogen.constraints_state_seq_iter","text":"constraints_state_seq_iter(\n    m,\n    n::Reformer,\n    per,\n    t_last,\n    ts,\n    modeltype::EnergyModel\n)\n\nFunction for iterating through the time structure for calculating the correct cyclic constraints for the sequencing of the states of the Reformer n.\n\nThe function automatically deduces the provided time structure and calls the calls the corresponding functions iteratively. It eventually calls the function constraints_state_seq for imposing the sequencing constraints on the different states.\n\nWhen the time structure includes RepresentativePeriods, period t_last is updated with last operational period within each representative period.\n\n\n\n\n\nWhen the time structure includes OperationalScenarios, period t_last is updated with last operational period within each operational scenario.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-EMH/#EnergyModelsHydrogen.constraints_state_seq","page":"Methods - Internal","title":"EnergyModelsHydrogen.constraints_state_seq","text":"constraints_state_seq(\n    m,\n    n::Reformer,\n    ref_pers::RefPeriods,\n    state_a::Symbol,\n    state_b::Symbol,\n    modeltype::EnergyModel,\n)\n\nFunction for creating the constraints on the sequencing of the individual states when state_b has to occur after state_a. Both state_a and state_b refer in this case to binary variables included in the JuMP model.\n\nThe function prev_op is used to incorporate the cyclic constraints.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-EMH/#EnergyModelsHydrogen.constraints_state_time_iter","page":"Methods - Internal","title":"EnergyModelsHydrogen.constraints_state_time_iter","text":"constraints_state_time_iter(\n    m,\n    n::Reformer,\n    per,\n    t_last,\n    ts,\n    modeltype::EnergyModel\n)\n\nFunction for iterating through the time structure for calculating the correct requirement for the length of the individual states.\n\nWhen the time structure includes RepresentativePeriods, period t_last is updated with last operational period within each representative period.\n\n\n\n\n\nWhen the time structure includes OperationalScenarios, period t_last is updated with last operational period within each operational scenario.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-EMH/#lib-int-met-check","page":"Methods - Internal","title":"Check methods","text":"","category":"section"},{"location":"library/internals/methods-EMH/","page":"Methods - Internal","title":"Methods - Internal","text":"EnergyModelsHydrogen.check_load_lim\nEnergyModelsHydrogen.check_commitment_profile","category":"page"},{"location":"library/internals/methods-EMH/#EnergyModelsHydrogen.check_load_lim","page":"Methods - Internal","title":"EnergyModelsHydrogen.check_load_lim","text":"check_load_lim(n, 𝒯)\n\nChecks the limits for the capacity load.\n\nChecks\n\nThe field min_load is required to be non-negative.\nThe field max_load is required to be larger than the field min_load.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-EMH/#EnergyModelsHydrogen.check_commitment_profile","page":"Methods - Internal","title":"EnergyModelsHydrogen.check_commitment_profile","text":"check_commitment_profile(\n    time_profile::TimeProfile,\n    𝒯::TwoLevel,\n    field_name::String,\n    check_timeprofiles::Bool\n)\n\nChecks that the unit commitment time_profile for the field field_name follows the given TimeStructure 𝒯.\n\nChecks\n\nThe time_profile cannot have a finer granulation than RepresentativeProfile through calling the function EnergyModelsBase.check_representative_profile.\nThe time_profile must be non-negative.\n\nConditional checks (if check_timeprofiles=true)\n\nThe time_profiles have to have the same length as the number of strategic or representative periods.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-EMH/#lib-int-met-util","page":"Methods - Internal","title":"Utility methods","text":"","category":"section"},{"location":"library/internals/methods-EMH/","page":"Methods - Internal","title":"Methods - Internal","text":"EnergyModelsHydrogen.capacity_max\nEnergyModelsHydrogen.linear_reformulation\nEnergyModelsHydrogen.multiplication_variables\nEnergyModelsHydrogen.fix_elect_on_b\nEnergyModelsHydrogen.ramp_disjunct\nEnergyModelsHydrogen.compression_energy\nEnergyModelsHydrogen.energy_curve","category":"page"},{"location":"library/internals/methods-EMH/#EnergyModelsHydrogen.capacity_max","page":"Methods - Internal","title":"EnergyModelsHydrogen.capacity_max","text":"capacity_max(n::AbstractElectrolyzer, t_inv, modeltype::EnergyModel)\n\nFunction for calculating the maximum capacity.\n\nmodeltype::EnergyModel\n\nWhen the modeltype is an EnergyModel, it returns the capacity of the AbstractElectrolyzer.\n\nmodeltype::AbstractInvestmentModel\n\nWhen the modeltype is an AbstractInvestmentModel, it returns the maximum installed capacity.\n\nnote: Note\nIf the AbstractElectrolyzer node does not have investments, it reuses the default function.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-EMH/#EnergyModelsHydrogen.linear_reformulation","page":"Methods - Internal","title":"EnergyModelsHydrogen.linear_reformulation","text":"linear_reformulation(\n    m,\n    𝒯,\n    var_binary,\n    var_continuous,\n    lb::TimeProfile,\n    ub::TimeProfile,\n)\n\nLinear reformulation of the element-wise multiplication of the binary variable var_binary[𝒯] and the continuous variable var_continuous[𝒯] ∈ [ub, lb].\n\nIt returns the product var_aux[𝒯] with\n\nvar_auxt = var_binaryt times var_continuoust.\n\nnote: Note\nThe bounds lb and ub must have the ability to access their fields using the iterator of 𝒯, that is if 𝒯 corresponds to the strategic periods, it is not possible to provide an OperationalProfile or RepresentativeProfile.\n\n\n\n\n\nlinear_reformulation(\n    m,\n    𝒯ᵃ::T,\n    𝒯ᵇ::T,\n    var_binary,\n    var_continuous,\n    lb::TimeProfile,\n    ub::TimeProfile,\n) where {T}\n\nLinear reformulation of the multiplication of the binary variable var_binary[𝒯ᵃ, 𝒯ᵇ] and the continuous variable var_continuous[𝒯ᵇ] ∈ [ub, lb].\n\nIt returns the product var_aux[𝒯ᵃ, 𝒯ᵇ] with\n\nvar_auxt_a t_b = var_binaryt_a t_b times var_continuoust_b.\n\nnote: Note\n𝒯ᵃ and 𝒯ᵇ must be of the same type, that is either, e.g. a TwoLevel, AbstractStratPers, StratReprPeriods, or comparable. This is enforced through the parametric type T.The bounds lb and ub must have the ability to access their fields using the iterator of 𝒯ᵃ, that is if 𝒯ᵃ corresponds to the strategic periods, it is not possible to provide an OperationalProfile or RepresentativeProfile.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-EMH/#EnergyModelsHydrogen.multiplication_variables","page":"Methods - Internal","title":"EnergyModelsHydrogen.multiplication_variables","text":"multiplication_variables(\n    m,\n    n::AbstractHydrogenNetworkNode,\n    𝒯,\n    var_b,\n    modeltype::EnergyModel\n)\n\nFunction for calculating the muliplication of the capacity of an AbstractHydrogenNetworkNode and a binary variable.\n\nmodeltype::EnergyModel\n\nMultiplication of the installed capacity (expressed through capacity(n, t)) and a binary variable var_b in a period t (e.g., elect_on_b[n, t]).\n\nnote: Note\nThe time structure 𝒯 can be either a TwoLevel or StrategicPeriods. It is however necessary, that the variable var_b is indexed over the iterators of 𝒯.\n\nReturns\n\nprod[t]: Multiplication of capacity(n, t) and var_b[n, t].\n\nmodeltype::AbstractInvestmentModel\n\nWhen the modeltype is an AbstractInvestmentModel, then the function applies a linear reformulation of the binary-continuous multiplication based on the McCormick relaxation and the function linear_reformulation.\n\nnote: Note\nIf the AbstractHydrogenNetworkNode node does not have investments, it reuses the default function to avoid increasing the number of variables in the model.\n\nReturns\n\nprod[t]: Multiplication of cap_inst[n, t] and var_b[t] or alternatively cap_current[n, t] and var_b[t], if the TimeStructure is a StrategicPeriods and the node n has investments.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-EMH/#EnergyModelsHydrogen.fix_elect_on_b","page":"Methods - Internal","title":"EnergyModelsHydrogen.fix_elect_on_b","text":"fix_elect_on_b(m, n::AbstractElectrolyzer, 𝒯, 𝒫, modeltype::EnergyModel)\n\nFixes the variable :elect_on_b  in operational periods without capacity and the variable :elect_stack_replace_b in strategic periods without capacity to 0 to simplify the optimziation problem.\n\nProvides start values to the variables in all other periods as well as start values for the variable :elect_usage_mult_sp_b\n\nmodeltype::EnergyModel\n\nThe function utilizes the the value of the field cap of the node.\n\nmodeltype::AbstractInvestmentModel\n\nWhen the node has investment data, the function utilizes the the value of the field EMI.max_add of the AbstractInvData. Otherwise, it uses as well the field cap of the node.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-EMH/#EnergyModelsHydrogen.ramp_disjunct","page":"Methods - Internal","title":"EnergyModelsHydrogen.ramp_disjunct","text":"ramp_disjunct(m, n::Reformer, ref_pers::RefPeriods, modeltype::EnergyModel)\n\nFunction for calculating the disjunction contribution for the ramping constraints of a reformer.\n\nmodeltype::EnergyModel\n\nThe function utilizes the the value of the field cap of the node for achieving tight bounds for the disjunction.\n\nmodeltype::AbstractInvestmentModel\n\nWhen the node has investment data, the function utilizes the the value of the field EMI.max_installed of the AbstractInvData for achieving tight bounds for the disjunction. Otherwise, it uses as well the field cap of the node.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-EMH/#EnergyModelsHydrogen.compression_energy","page":"Methods - Internal","title":"EnergyModelsHydrogen.compression_energy","text":"compression_energy(p₁, p₂; T₁=298.15, κ=1.41, η=0.75)\n\nReturns the required compression energy for a compression from pressure p₁ to p₂. The compression energy is in principle based on isentropic compression. The unit of the compression energy is J/mol.\n\nArguments\n\np₁ is the inlet pressure to the compressor. The unit for pressure is not relevant.\np₂ is the outlet pressure from the compressor. The unit for pressure is not relevant, but it must be the same unit as p₁.\n\nKeyword arguments\n\nT₁ is the inlet temperature to the compressor.\nκ is the ratio of specific heats. Using a value of [1, κ] would correspond hence to polytropic compression.\nη is the efficiency of the compressor.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-EMH/#EnergyModelsHydrogen.energy_curve","page":"Methods - Internal","title":"EnergyModelsHydrogen.energy_curve","text":"energy_curve(\n    p::Float64,\n    pᵢₙ::Float64,\n    PR::Float64,\n    n_comp::Int,\n    M::Float64,\n    LHV::Float64\n)\n\nReturns the relative compression energy requirement for a multi-stage compression train.\n\nArguments\n\np::Float64 is the delivery pressure.\npᵢₙ::Float64 is the inlet pressure.\nPR::Float64 is the compression rate of each compressor in the train.\nn_comp::Int is the number of compressors in the train.\nM::Float64 is molecular mass of the compressed gas.\nLHV::Float64 is the mass lower heating value of the compressed gas.\n\nKeyword arguments\n\nT₁ is the inlet temperature to the compressor.\nκ is the ratio of specific heats. Using a value of [1, κ] would correspond hence to polytropic compression.\nη is the efficiency of the compressor.\n\nwarning: Units\nThe units have to be consistent. This implies that both p and pᵢₙ require to have the same unit. The molecular mass should be provided in g/mol while the lower heating value should be given in MJ/kg.\n\n\n\n\n\n","category":"function"},{"location":"manual/quick-start/#man-quick_start","page":"Quick Start","title":"Quick Start","text":"","category":"section"},{"location":"manual/quick-start/","page":"Quick Start","title":"Quick Start","text":"Install the most recent version of Julia\nInstall the package EnergyModelsBase and the time package TimeStruct, by running:\n] add TimeStruct\n] add EnergyModelsBase\nThese packages are required as we do not only use them internally, but also for building a model.\nInstall the package EnergyModelsHydrogen\n] add EnergyModelsHydrogen","category":"page"},{"location":"manual/quick-start/","page":"Quick Start","title":"Quick Start","text":"You also have to install a solver for solving the optimization problem. Depending on the type of node you plan to utilize, you can either use a standard solver or a solver supporting MOI.ScalarQuadraticFunction{Float64} in MOI.EqualTo{Float64}. In either case, you have to","category":"page"},{"location":"manual/quick-start/","page":"Quick Start","title":"Quick Start","text":"Install JuMP by running:\n] add JuMP\nInstall your chosen solver, e.g., SCIP and Gurobi, by running:","category":"page"},{"location":"manual/quick-start/","page":"Quick Start","title":"Quick Start","text":"julia   ] add SCIP   ] add Gurobi","category":"page"},{"location":"manual/quick-start/","page":"Quick Start","title":"Quick Start","text":"You may, depending on your operating system, also have to locally install the solver in addition as explained in the corresponding README file.","category":"page"},{"location":"manual/quick-start/","page":"Quick Start","title":"Quick Start","text":"tip: JuMP and solver\nWhile JuMP is automatically installed when you add EnergyModelsBase, it is still necessary to load it to optimize a model or extract the results. It is hence necessary to load it in each model run explicitly.EnergyModelsX models are in general agnostic towards which solver is used. They are hence not automatically included. Therefore, they require you to explicitly load the corresponding solver.","category":"page"},{"location":"library/internals/methods-EMB/#lib-int-met_emb","page":"Methods - EnergyModelsBase","title":"Methods - EnergyModelsBase","text":"","category":"section"},{"location":"library/internals/methods-EMB/#lib-int-met_emb-idx","page":"Methods - EnergyModelsBase","title":"Index","text":"","category":"section"},{"location":"library/internals/methods-EMB/","page":"Methods - EnergyModelsBase","title":"Methods - EnergyModelsBase","text":"Pages = [\"methods-EMB.md\"]","category":"page"},{"location":"library/internals/methods-EMB/#lib-int-met_emb-ext","page":"Methods - EnergyModelsBase","title":"Extension methods","text":"","category":"section"},{"location":"library/internals/methods-EMB/","page":"Methods - EnergyModelsBase","title":"Methods - EnergyModelsBase","text":"EnergyModelsBase.variables_node\nEnergyModelsBase.create_node","category":"page"},{"location":"library/internals/methods-EMB/#EnergyModelsBase.variables_node","page":"Methods - EnergyModelsBase","title":"EnergyModelsBase.variables_node","text":"variables_node(m, 𝒩ˢᵗᵒʳ::Vector{<:AbstractElectrolyzer}, 𝒯, modeltype::EnergyModel)\n\nCreates the following additional variables for ALL electrolyzer nodes:\n\nelect_on_b[n, t] is binary variable which is 1 if electrolyzer n is operating in operational period t.\nelect_prev_use[n, t] is the total use of the electrolyzer n in all previous operational periods up to operational period t since the last stack replacement. The value is provided in 1000 operational periods duration to avoid a too large matrix range.\nelect_prev_use_sp[n, t_inv] is the total use of the electrolyzer n in all previous investment periods up to investment period t_inv since the last stack replacement. The value is provided in 1000 operational periods duration to avoid a too large matrix range.\nelect_use_sp[n, t_inv] is the total time of usage of electrolyzer n in investment period t_inv. The value is provided in 1000 operational periods duration to avoid a too large matrix range.\nelect_use_rp[n, t_rp] is the total time of usage of electrolyzer n in representative period t_rp, declared if the TimeStructure includes RepresentativePeriods. The value is provided in 1000 operational periods duration to avoid a too large matrix range.\nelect_stack_replace_b[n, tinv] is a binary variable to indicate if electrolyzer n has stack replacement (value of 1) in investment period `tinv`. In this case, the efficiency penalty is reset to 0.\nelect_efficiency_penalty[n, t] is a coefficient that accounts for drop in efficiency of electrolyzer n in  operational period due to degradation in the electrolyzer. It starts at 1 and is reset to 1 at the beginning of the investment period with stack replacement\n\n\n\n\n\nEMB.variables_node(m, 𝒩ʳᵉᶠ::Vector{Reformer}, 𝒯, modeltype::EnergyModel)\n\nCreates the following additional variables for ALL reformer nodes:\n\nref_off_b[n, t] is a binary variable which is 1 if reformer n is in state off in operational period t.\nref_start_b[n, t] is a binary variable which is 1 if reformer n is in state start-up in operational period t.\nref_on_b[n, t] is a binary variable which is 1 if reformer n is in state on in operational period t.\nref_shut_b[n, t] is a binary variable which is 1 if reformer n is in state shutdown in operational period t.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-EMB/#EnergyModelsBase.create_node","page":"Methods - EnergyModelsBase","title":"EnergyModelsBase.create_node","text":"EMB.create_node(m, n::AbstractElectrolyzer, 𝒯, 𝒫,  modeltype::EnergyModel)\n\nSet all constraints for an AbstractElectrolyzer. Can serve as fallback option for all unspecified subtypes of AbstractElectrolyzer.\n\nIt differs from the function for a standard RefNetworkNode node through both calling additional functions as well as for calculations within the function.\n\nCalled constraint functions\n\nconstraints_usage,\nconstraints_data for all node_data(n),\nconstraints_flow_in,\nconstraints_flow_out,\nconstraints_capacity, and\nconstraints_opex_var.\n\n\n\n\n\nEMB.create_node(m, n::Reformer, 𝒯, 𝒫, modeltype::EnergyModel)\n\nSet all constraints for a Reformer.\n\nIt differs from the function for a standard RefNetworkNode node through both calling additional functions as well as for calculations within the function.\n\nCalled constraint functions\n\nconstraints_flow_in,\nconstraints_flow_out,\nconstraints_data for all node_data(n),\nconstraints_capacity,\nconstraints_state_seq_iter,\nconstraints_state_time_iter,\nconstraints_rate_of_change_iterate,\nconstraints_opex_fixed, and\nconstraints_opex_var.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-EMB/#lib-int-met_emb-con","page":"Methods - EnergyModelsBase","title":"Constraint methods","text":"","category":"section"},{"location":"library/internals/methods-EMB/","page":"Methods - EnergyModelsBase","title":"Methods - EnergyModelsBase","text":"EnergyModelsBase.constraints_capacity\nEnergyModelsBase.constraints_flow_in\nEnergyModelsBase.constraints_flow_out\nEnergyModelsBase.constraints_opex_var","category":"page"},{"location":"library/internals/methods-EMB/#EnergyModelsBase.constraints_capacity","page":"Methods - EnergyModelsBase","title":"EnergyModelsBase.constraints_capacity","text":"EMB.constraints_capacity(\n    m,\n    n::AbstractHydrogenNetworkNode,\n    𝒯::TimeStructure,\n    var,\n    modeltype::EnergyModel\n)\n\nFunction for creating operational limits of an AbstractHydrogenNetworkNode.\n\nThe operational limits limit the capacity usage of the electrolyzer node between a minimimum and maximum load based on the installed capacity.\n\nTODO:\n\nConsider the application of the upper bound only for systems in which the efficiency is given by a piecewise linear function to account for the increased energy demand at loads above the nominal capacity.\n\n\n\n\n\nEMB.constraints_capacity(\n    m,\n    n::AbstractH2Storage,\n    𝒯::TimeStructure,\n    modeltype::EnergyModel\n)\n\nFunction for creating the constraints on the :stor_level, :stor_charge_use, and :stor_discharge_use variables for a AbstractH2Storage node.\n\nThe discharge :stor_discharge_use is limited by the installed charging capacity stor_charge_inst and the multiplier discharge_charge due to the limitations given by the physical integrity of the storage vessel and/or the injection connection.\n\nThe installed charge capacity :stor_charge_inst times its field level_charge has an upper bound given by the installed storage capacity stor_level_inst. In the case of operational models, this is checked while in the case of investment models, it is constrained.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-EMB/#EnergyModelsBase.constraints_flow_in","page":"Methods - EnergyModelsBase","title":"EnergyModelsBase.constraints_flow_in","text":"EMB.constraints_flow_in(m, n::HydrogenStorage, 𝒯::TimeStructure, modeltype::EnergyModel)\n\nFunction for creating the constraint on the inlet flow to a HydrogenStorage node.\n\nIt differs from the reference description by considering the dependency of the compression power on the storage level.\n\nThis is achieved through calling the subfunction energy_curve for the different breakpoints in the compression curve.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-EMB/#EnergyModelsBase.constraints_flow_out","page":"Methods - EnergyModelsBase","title":"EnergyModelsBase.constraints_flow_out","text":"EMB.constraints_flow_out(m, n::Electrolyzer, 𝒯::TimeStructure, modeltype::EnergyModel)\n\nFunction for creating the constraint on the outlet flow from an Electrolyzer node. It differs from the reference description by taking into account stack degradation through the variable :elect_efficiency_penalty.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-EMB/#EnergyModelsBase.constraints_opex_var","page":"Methods - EnergyModelsBase","title":"EnergyModelsBase.constraints_opex_var","text":"EMB.constraints_opex_var(m, n::Reformer, 𝒯ᴵⁿᵛ, modeltype::EnergyModel)\n\nFunction for creating the constraint on the variable OPEX of a Reformer node. It differs from the reference description through the incorporation of additional costs in each state of the node.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-EMB/#lib-int-met_emb-check","page":"Methods - EnergyModelsBase","title":"Check methods","text":"","category":"section"},{"location":"library/internals/methods-EMB/","page":"Methods - EnergyModelsBase","title":"Methods - EnergyModelsBase","text":"EnergyModelsBase.check_node\nEnergyModelsBase.check_node_data","category":"page"},{"location":"library/internals/methods-EMB/#EnergyModelsBase.check_node","page":"Methods - EnergyModelsBase","title":"EnergyModelsBase.check_node","text":"EMB.check_node(n::AbstractElectrolyzer, 𝒯, modeltype::EnergyModel, check_timeprofiles::Bool)\n\nThis method checks that an AbstractElectrolyzer node is valid.\n\nIt reuses the standard checks of a NetworkNode node through calling the function EMB.check_node_default, but adds an additional check on the data.\n\nChecks\n\nThe field cap is required to be non-negative.\nThe value of the field fixed_opex is required to be non-negative and accessible through a StrategicPeriod as outlined in the function EMB.check_fixed_opex().\nThe values of the dictionary input are required to be non-negative.\nThe values of the dictionary output are required to be non-negative.\nThe lower limit on capacity utilization is required ot be non-negative while the upper\nlimit is required to be larger or equal than the lower limit as described in the check_load_lim()\nThe field degradation_rate is required to be in the range [0,1).\nThe TimeProfile of the field stack_replacement is required to be non-negative and accessible through a StrategicPeriod as outlined in the function EMB.check_fixed_opex().\nThe field stack_lifetime is required to be non-negative.\n\n\n\n\n\nEMB.check_node(n::AbstractReformer, 𝒯, modeltype::EnergyModel, check_timeprofiles::Bool)\n\nThis method checks that an AbstractReformer node is valid.\n\nIt reuses the standard checks of a NetworkNode node through calling the function EMB.check_node_default, but adds an additional check on the data.\n\nChecks\n\nThe field cap is required to be non-negative.\nThe value of the field fixed_opex is required to be non-negative and accessible through a StrategicPeriod as outlined in the function EMB.check_fixed_opex().\nThe values of the dictionary input are required to be non-negative.\nThe values of the dictionary output are required to be non-negative.\nThe lower limit on capacity utilization is required ot be non-negative while the upper limit is required to be larger or equal than the lower limit as described in the check_load_lim()\nThe field opex of the CommitParameters of the fields startup, shutdown, and off is required to be non-negative.\nThe field time of the CommitParameters of the fields startup, shutdown, and off is required to be non-negative and accessible through a StrategicPeriod, or Representativeperiod as outlined in the function check_commitment_profile.\nThe field rate_limit is required to be in the range [0,1].\n\n\n\n\n\nEMB.check_node(n::SimpleHydrogenStorage, 𝒯, modeltype::EnergyModel, check_timeprofiles::Bool)\n\nThis method checks that a SimpleHydrogenStorage node is valid.\n\nIt reuses the standard checks of a Storage node through calling the function EMB.check_node_default, but adds an additional check on the data.\n\nChecks\n\nThe TimeProfile of the field capacity in the type in the field charge is required to be non-negative.\nThe TimeProfile of the field capacity in the type in the field level is required to be non-negative`.\nThe TimeProfile of the field fixed_opex is required to be non-negative and accessible through a StrategicPeriod as outlined in the function check_fixed_opex for the chosen composite type.\nThe values of the dictionary input are required to be non-negative.\nThe values of the dictionary output are required to be non-negative.\nThe value of the field discharge_charge is required to be positive.\nThe value of the field level_charge is required to be positive. The provided capacities in the AbstractStorageParameters charge and `level cannot violate the value.\n\n\n\n\n\nEMB.check_node(n::HydrogenStorage, 𝒯, modeltype::EnergyModel, check_timeprofiles::Bool)\n\nThis method checks that a HydrogenStorage node is valid.\n\nIt reuses the standard checks of a Storage node through calling the function EMB.check_node_default, but adds an additional check on the data.\n\nChecks\n\nThe TimeProfile of the field capacity in the type in the field charge is required to be non-negative.\nThe TimeProfile of the field capacity in the type in the field level is required to be non-negative`.\nThe TimeProfile of the field fixed_opex is required to be non-negative and accessible through a StrategicPeriod as outlined in the function check_fixed_opex for the chosen composite type.\nThe values of the dictionary input are required to be non-negative.\nThe values of the dictionary output are required to be non-negative.\nThe value of the field discharge_charge is required to be positive.\nThe value of the field level_charge is required to be positive. The provided capacities in the AbstractStorageParameters charge and `level cannot violate the value.\nThe values of the fields p_min, p_charge, and p_max are required to be positive.\nThe values of the fields p_min and p_charge must be smaller than p_max.\nThe value of the field p_charge must be smaller than p_min.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-EMB/#EnergyModelsBase.check_node_data","page":"Methods - EnergyModelsBase","title":"EnergyModelsBase.check_node_data","text":"EMB.check_node_data(n::HydrogenStorage, data::InvestmentData, 𝒯, modeltype::AbstractInvestmentModel, check_timeprofiles::Bool)\n\nAs HydrogenStorage nodes cannot utilize investments at the time being, a separate function is required\n\nChecks\n\nNo investment data is allowed\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-EMB/#lib-int-met_emb-field","page":"Methods - EnergyModelsBase","title":"Field extraction methods","text":"","category":"section"},{"location":"library/internals/methods-EMB/","page":"Methods - EnergyModelsBase","title":"Methods - EnergyModelsBase","text":"EnergyModelsBase.inputs\nEnergyModelsBase.outputs","category":"page"},{"location":"library/internals/methods-EMB/#EnergyModelsBase.inputs","page":"Methods - EnergyModelsBase","title":"EnergyModelsBase.inputs","text":"inputs(n::HydrogenStorage)\ninputs(n::HydrogenStorage, p::Resource)\n\nWhen the node n is a HydrogenStorage, the function returns either both the stored and the electricity resource or a value of 1, if a resource p is specified.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-EMB/#EnergyModelsBase.outputs","page":"Methods - EnergyModelsBase","title":"EnergyModelsBase.outputs","text":"outputs(n::HydrogenStorage)\noutputs(n::HydrogenStorage, p::Resource)\n\nWhen the node n is a HydrogenStorage, the function returns either the stored resource or a value of 1, if a resource p is specified.\n\n\n\n\n\n","category":"function"},{"location":"nodes/h2_storage/#nodes-h2_storage","page":"H₂ storage","title":"Hydrogen storage nodes","text":"","category":"section"},{"location":"nodes/h2_storage/","page":"H₂ storage","title":"H₂ storage","text":"Hydrogen storage nodes are in some aspects differing from standard Storage nodes. A first difference is that the maximum installed charge capacity is dependent on the maximum installed storage level capacity. The reason for this dependency is that the stability of the storage allows only for small storage level changes. In the case of gas storage, fast pressure changes would have a significant impact on the stability of the storage vessel (or alternatively the cavern, when stored in salt caverns). A second difference is that the maximum discharge rate is normally stated as a multiple of the charge rate. This can be explained as well by the stability of the storage in which large pressure changes should be avoided.","category":"page"},{"location":"nodes/h2_storage/","page":"H₂ storage","title":"H₂ storage","text":"As a consequence, new nodal descriptions are incorporated in EnergyModelsHydrogen specifically for modelling hydrogen storage.","category":"page"},{"location":"nodes/h2_storage/#nodes-h2_storage-fields","page":"H₂ storage","title":"Introduced types and their fields","text":"","category":"section"},{"location":"nodes/h2_storage/","page":"H₂ storage","title":"H₂ storage","text":"EnergyModelsHydrogen introduces two hydrogen storage nodes, SimpleHydrogenStorage and HydrogenStorage.","category":"page"},{"location":"nodes/h2_storage/","page":"H₂ storage","title":"H₂ storage","text":"SimpleHydrogenStorage nodes incorporate the constraints on the maximum discharge from the storage as well as the constraint on the maximum charge rate to storage capacity. The latter is used in the internal checks, if a standard operational model is utilized, while it restricts investments in capacity expansions models.","category":"page"},{"location":"nodes/h2_storage/","page":"H₂ storage","title":"H₂ storage","text":"HydrogenStorage nodes include all constraints from SimpleHydrogenStorage nodes. In addition, the nodes include a storage level dependent term for the electricity requirement. This is implemented as a combination of a bilinear term and a piecewise linear interpolation using Special Ordered Sets of Type 2 constraints.","category":"page"},{"location":"nodes/h2_storage/","page":"H₂ storage","title":"H₂ storage","text":"warning: `HydrogenStorage` nodes and investment models\nThe current implementation of HydrogenStorage nodes does not allow their usage in capacity expansion models. The optimization problem would in this case include a bilinear term on the flow into the storage node, the current capacity, and the current storage level. This leads to a complex optimization model. As a consequence, we decided to only allow HydrogenStorage nodes in operational models.This is checked through the function EMB.check_node_data in the EnergyModelsInvestments extension.","category":"page"},{"location":"nodes/h2_storage/#nodes-h2_storage-fields-stand","page":"H₂ storage","title":"Standard fields","text":"","category":"section"},{"location":"nodes/h2_storage/","page":"H₂ storage","title":"H₂ storage","text":"The fields of both storage nodes are given as:","category":"page"},{"location":"nodes/h2_storage/","page":"H₂ storage","title":"H₂ storage","text":"id:\nThe field id is only used for providing a name to the node.\ncharge::UnionCapacity:\nThe charge storage parameters must include a capacity. More information can be found on storage parameters.\nlevel::UnionCapacity:\nThe level storage parameters must include a capacity. More information can be found on storage parameters.\nnote: Permitted values for storage parameters in `charge` and `level`\nIf the node should contain investments through the application of EnergyModelsInvestments, it is important to note that you can only use FixedProfile or StrategicProfile for the capacity, but not RepresentativeProfile or OperationalProfile. Similarly, you can only use FixedProfile or StrategicProfile for the fixed OPEX, but not RepresentativeProfile or OperationalProfile. The variable operating expenses can be provided as OperationalProfile as well. In addition, all capacity and fixed OPEX values have to be non-negative.\nstor_res::ResourceCarrier:\nThe stor_res is the stored Resource.\ninput::Dict{<:Resource,<:Real} and output::Dict{<:Resource,<:Real}:\nBoth fields describe the input and output Resources with their corresponding conversion factors as dictionaries. All values have to be non-negative.\ninfo: Meaning in both nodes\nIn the case of a SimpleHydrogenStorage, the input should correspond to the hydogen and electricity resources. The chosen value in the dictionary for the hydrogen resource is not relevant. However, the chosen value for the electricity resource impacts the required compression energy.HydrogenStorage do not have the fields input and output. The individual resources used as input and output are instead obtained through dispatching on the functions inputs and outputs. The inputs correspond in this case to the field stor_res and el_res. The latter is explained the following section.\ndata::Vector{Data}:\nAn entry for providing additional data to the model. In the current version, it is used for providing additional investment data when EnergyModelsInvestments is used.\nnote: Note\nThe field data is not required as we include a constructor when the value is excluded. The current implementation of HydrogenStorage does not allow for investment data.","category":"page"},{"location":"nodes/h2_storage/#nodes-h2_storage-fields-new","page":"H₂ storage","title":"Additional fields","text":"","category":"section"},{"location":"nodes/h2_storage/","page":"H₂ storage","title":"H₂ storage","text":"AbstractH2Storage nodes add additional fields compared to RefStorage nodes. The location of the fields is changing. Hence, it is beneficial to use the docstrings (SimpleHydrogenStorage and HydrogenStorage) in which the order is included.","category":"page"},{"location":"nodes/h2_storage/","page":"H₂ storage","title":"H₂ storage","text":"The individual fields are related to specifics of storing gases. Boths nodes have the following fields:","category":"page"},{"location":"nodes/h2_storage/","page":"H₂ storage","title":"H₂ storage","text":"discharge_charge::Float64:\nThe discharge to charge ratio specifies the maximum allowed discharge as a ratio of the installed charging capacity. It is important due to the stability of the storage vessel or cavern. As a consequence of its introduction, it is not possible to specify a discharge capacity to the storage node.\nlevel_charge::Float64:\nThe level to charge ratio specifies the maximum allowed storage level capacity as a ratio of the charging capacity. The implementation is rquired to avoid large pressure changes in the vessel in a short period.","category":"page"},{"location":"nodes/h2_storage/","page":"H₂ storage","title":"H₂ storage","text":"note: Allowed values\nBoth ratios have to be positive. The field level_charge is in operational models only used for checking the provided input capacities while it is used in investment models to restrict the investments in the charge capacity.","category":"page"},{"location":"nodes/h2_storage/","page":"H₂ storage","title":"H₂ storage","text":"HydrogenStorage have in addition several fields:","category":"page"},{"location":"nodes/h2_storage/","page":"H₂ storage","title":"H₂ storage","text":"el_res::ResourceEmit:\nThe el_res is the Resource that corresponds in the chosen system to electricity. It is required to specify it to avoid\np_min::Float64:\nThe minimum pressure in the vessel is required for stability purposes. The implementation of the minimum pressure requires a cushion gas which always remains in the storage vessel. The cushion gas is not included in the analysis. It must be instead included in the storage level capital expenditures as it is linear proportional to the storage level capacity.\nThe value is\np_charge::Float64:\nThe charge pressure is the pressure used to calculate the required electricity for compressing the gas to the storage pressure. It corresponds to the pressure at the boundaries of the storage node.\np_max::Float64:\nThe maximum pressure in the vessel is also required for stability purposes. Depending on the storage type, this pressure is either defined through the wall properties (when considering small on-site storage) or through the depth (when considering storage in salt caverns).","category":"page"},{"location":"nodes/h2_storage/","page":"H₂ storage","title":"H₂ storage","text":"note: Allowed values and units\nAll pressures have to be positive. The maximum pressure p_max has to be larger than the minimum pressure p_min. The charging pressure p_charge can be any positive value. If it is larger than p_max, it is however beneficial to use a SimpleHydrogenStorage instead without an electricity input as no compression is required.","category":"page"},{"location":"nodes/h2_storage/#nodes-h2_storage-math","page":"H₂ storage","title":"Mathematical description","text":"","category":"section"},{"location":"nodes/h2_storage/","page":"H₂ storage","title":"H₂ storage","text":"In the following mathematical equations, we use the name for variables and functions used in the model. Variables are in general represented as","category":"page"},{"location":"nodes/h2_storage/","page":"H₂ storage","title":"H₂ storage","text":"textttvar_exampleindex_1 index_2","category":"page"},{"location":"nodes/h2_storage/","page":"H₂ storage","title":"H₂ storage","text":"with square brackets, while functions are represented as","category":"page"},{"location":"nodes/h2_storage/","page":"H₂ storage","title":"H₂ storage","text":"func_example(index_1 index_2)","category":"page"},{"location":"nodes/h2_storage/","page":"H₂ storage","title":"H₂ storage","text":"with paranthesis.","category":"page"},{"location":"nodes/h2_storage/#nodes-h2_storage-math-var","page":"H₂ storage","title":"Variables","text":"","category":"section"},{"location":"nodes/h2_storage/","page":"H₂ storage","title":"H₂ storage","text":"The variables of both SimpleHydrogenStorage and HydrogenStorage nodes include:","category":"page"},{"location":"nodes/h2_storage/","page":"H₂ storage","title":"H₂ storage","text":"textttopex_var\ntextttopex_fixed\ntextttstor_level\ntextttstor_level_inst\ntextttstor_charge_use\ntextttstor_charge_inst\ntextttstor_discharge_use\ntextttflow_in\ntextttflow_out\ntextttstor_level_Δ_op\ntextttstor_level_Δ_rp if the TimeStruct includes RepresentativePeriods","category":"page"},{"location":"nodes/h2_storage/#nodes-h2_storage-math-con","page":"H₂ storage","title":"Constraints","text":"","category":"section"},{"location":"nodes/h2_storage/","page":"H₂ storage","title":"H₂ storage","text":"The following sections omit the direct inclusion of the vector of hydrogen storage nodes. Instead, it is implicitly assumed that the constraints are valid forall n  N for all SimpleHydrogenStorage or HydrogenStorage types if not stated differently. In addition, all constraints are valid forall t in T (that is in all operational periods) or forall t_inv in T^Inv (that is in all investment periods).","category":"page"},{"location":"nodes/h2_storage/#nodes-h2_storage-math-con-stand","page":"H₂ storage","title":"Standard constraints","text":"","category":"section"},{"location":"nodes/h2_storage/","page":"H₂ storage","title":"H₂ storage","text":"Hydrogen storages nodes utilize in general the standard constraints described on Constraint functions for RefStorage nodes.","category":"page"},{"location":"nodes/h2_storage/","page":"H₂ storage","title":"H₂ storage","text":"These standard constraints are:","category":"page"},{"location":"nodes/h2_storage/","page":"H₂ storage","title":"H₂ storage","text":"constraints_capacity_installed:\nbeginaligned\ntextttstor_level_instn t  = capacity(level(n) t) \ntextttstor_charge_instn t  = capacity(charge(n) t)\nendaligned\nconstraints_flow_in:\nThe flow into a hydrogen storage node is given by:\ntextttflow_inn t stor_res(n) = textttstor_charge_usen t\nThe flow of the electricity resource is dependent on the chosen type, and hence, explained below in detail.\nconstraints_flow_out:\ntextttflow_outn t stor_res(n) = textttstor_discharge_usen t\nconstraints_level:\nThe level constraints are more complex compared to the standard constraints. They are explained in detail below in Level constraints.\nconstraints_opex_fixed:\nbeginaligned\ntextttopex_fixedn t_inv =  \n  opex_fixed(level(n) t_inv) times textttstor_level_instn first(t_inv) +  \n  opex_fixed(charge(n) t_inv) times textttstor_charge_instn first(t_inv)\nendaligned\ntip: Why do we use `first()`\nThe variables textttstor_level_inst are declared over all operational periods (see the section on Capacity variables for further explanations). Hence, we use the function first(t_inv) to retrieve the installed capacities in the first operational period of a given investment period t_inv in the function constraints_opex_fixed.\nconstraints_opex_var:\nbeginaligned\ntextttopex_varn t_inv =  sum_t in t_inv\n  opex_var(level(n) t) times textttstor_leveln t times scale_op_sp(t_inv t) +  \n  opex_var(charge(n) t) times textttstor_charge_usen t times scale_op_sp(t_inv t)\nendaligned\ntip: The function `scale_op_sp`\nThe function scale_op_sp(t_inv t) calculates the scaling factor between operational and investment periods. It also takes into account potential operational scenarios and their probability as well as representative periods.\nconstraints_data:\nThis function is only called for specified data of the storage node, see above.","category":"page"},{"location":"nodes/h2_storage/","page":"H₂ storage","title":"H₂ storage","text":"info: Implementation of capacity and OPEX\nEven if an AbstractHStorage node includes the corresponding capacity field (i.e., charge, level), we only include the fixed and variable OPEX constribution for the different capacities if the corresponding storage parameters have a field opex_fixed and opex_var, respectively. Otherwise, they are omitted.","category":"page"},{"location":"nodes/h2_storage/","page":"H₂ storage","title":"H₂ storage","text":"Both hydrogen storage nodes provide a new method for the function EMB.constraints_capacity. While the standard constraints remain unchanged,","category":"page"},{"location":"nodes/h2_storage/","page":"H₂ storage","title":"H₂ storage","text":"beginaligned\ntextttstor_level_usen t  = textttstor_level_instn t \ntextttstor_charge_usen t  = textttstor_charge_instn t\nendaligned","category":"page"},{"location":"nodes/h2_storage/","page":"H₂ storage","title":"H₂ storage","text":"additional constraints are introduced to account for the introduced limits through the fields discharge_charge and level_charge:","category":"page"},{"location":"nodes/h2_storage/","page":"H₂ storage","title":"H₂ storage","text":"beginaligned\ntextttstor__discharge_usen t  leq discharge_charge(n) textttstor_charge_usen t \ntextttstor_charge_instn t level_charge(n)  leq textttstor_level_instn t\nendaligned","category":"page"},{"location":"nodes/h2_storage/","page":"H₂ storage","title":"H₂ storage","text":"The second constraint also limitsthe potential for investments in the charge capacity through the different constraints introduced in EnergyModelsBase.","category":"page"},{"location":"nodes/h2_storage/","page":"H₂ storage","title":"H₂ storage","text":"The function constraints_flow_in is different for SimpleHydrogenStorage and HydrogenStorage. SimpleHydrogenStorage nodes utilize the standard method. The auxiliary resource constraints are in this case given by:","category":"page"},{"location":"nodes/h2_storage/","page":"H₂ storage","title":"H₂ storage","text":"textttflow_inn t p = inputs(n p) times textttflow_inn stor_res(n)\nqquad forall p in inputs(n) setminus stor_res(n)","category":"page"},{"location":"nodes/h2_storage/","page":"H₂ storage","title":"H₂ storage","text":"HydrogenStorage nodes include a pressure dependent term for the required compression energy. As a consequence, the required electricity for compression is depending on both the hydrogen flow into the storage node and the storage level. The constraint is given by","category":"page"},{"location":"nodes/h2_storage/","page":"H₂ storage","title":"H₂ storage","text":"textttflow_inn t electricity_resource(n)  = textttflow_inn stor_res(n) times W_pt","category":"page"},{"location":"nodes/h2_storage/","page":"H₂ storage","title":"H₂ storage","text":"in which W_pt is dependent on the storage level. The calculation of W_pt is explained in the section Compression constraints","category":"page"},{"location":"nodes/h2_storage/#nodes-h2_storage-math-con-level","page":"H₂ storage","title":"Level constraints","text":"","category":"section"},{"location":"nodes/h2_storage/","page":"H₂ storage","title":"H₂ storage","text":"The level constraints are in general slightly more complex to understand. The overall structure is outlined on Constraint functions. The level constraints are called through the function constraints_level which then calls additional functions depending on the chosen time structure (whether it includes representative periods and/or operational scenarios) and the chosen storage behaviour.","category":"page"},{"location":"nodes/h2_storage/","page":"H₂ storage","title":"H₂ storage","text":"The hydrogen storage nodes utilize all concepts from EnergyModelsBase. They remain unchanged, but are repeated below for a concise understanding. If the time structure includes representative periods, we also calculate the change of the storage level in each representative period within the function constraints_level_iterate (from EnergyModelsBase):","category":"page"},{"location":"nodes/h2_storage/","page":"H₂ storage","title":"H₂ storage","text":"  textttstor_level_Δ_rpn t_rp = sum_t in t_rp\n  textttstor_level_Δ_opn t times scale_op_sp(t_inv t)","category":"page"},{"location":"nodes/h2_storage/","page":"H₂ storage","title":"H₂ storage","text":"The general level constraint is calculated in the function constraints_level_iterate (from EnergyModelsBase):","category":"page"},{"location":"nodes/h2_storage/","page":"H₂ storage","title":"H₂ storage","text":"textttstor_leveln t = prev_level +\ntextttstor_level_Δ_opn t times duration(t)","category":"page"},{"location":"nodes/h2_storage/","page":"H₂ storage","title":"H₂ storage","text":"in which the value prev_level is depending on the type of the previous operational (t_prev) and strategic level (t_invprev) (as well as the previous representative period (t_rpprev)). It is calculated through the function previous_level.","category":"page"},{"location":"nodes/h2_storage/","page":"H₂ storage","title":"H₂ storage","text":"In the case of hydropower node, we can distinguish the following cases:","category":"page"},{"location":"nodes/h2_storage/","page":"H₂ storage","title":"H₂ storage","text":"The first operational period in the first representative period in any investment period (given by typeof(t_prev) = typeof(t_rp prev) and typeof(t_invprev) = NothingPeriod). In this situation, we can distinguish three cases, the time structure does not include representative periods:\nprev_level = textttstor_leveln last(t_inv)\nthe time structure includes representative periods and the storage behavior is given as CyclicRepresentative:\nprev_level = textttstor_leveln last(t_rp)\nthe time structure includes representative periods and the storage behavior is given as CyclicStrategic:\nbeginaligned\n prev_level =  textttstor_leveln first(t_rplast) -  \n   textttstor_level_Δ_opn first(t_rplast) times duration(first(t_rplast)) +  \n   textttstor_level_Δ_rpn t_rplast times duration_strat(t_rplast)\nendaligned\nThe first operational period in subsequent representative periods in any investment period (given by typeof(t_prev) = nothing) f the the storage behavior is given as CyclicStrategic:\n\nbeginaligned\n prev_level =  textttstor_leveln first(t_rpprev) -  \n   textttstor_level_Δ_opn first(t_rpprev) times duration(first(t_rpprev)) +  \n   textttstor_level_Δ_rpn t_rpprev\nendaligned\nThis situation only occurs in cases in which the time structure includes representative periods.\nAll other operational periods:\n\n prev_level = textttstor_leveln t_prev","category":"page"},{"location":"nodes/h2_storage/","page":"H₂ storage","title":"H₂ storage","text":"All cases are implemented in EnergyModelsBase simplifying the design of the system.","category":"page"},{"location":"nodes/h2_storage/#nodes-h2_storage-math-con-comp","page":"H₂ storage","title":"Compression constraints","text":"","category":"section"},{"location":"nodes/h2_storage/","page":"H₂ storage","title":"H₂ storage","text":"The storage pressure p can be translated into the storage level assuming ideal gas behavior as","category":"page"},{"location":"nodes/h2_storage/","page":"H₂ storage","title":"H₂ storage","text":"textttstor_leveln t = fracp-p_minp_max-p_min capacity(level(n) t)","category":"page"},{"location":"nodes/h2_storage/","page":"H₂ storage","title":"H₂ storage","text":"in which p_min and p_max corresponds to the minimum and maximum pressure, respectively. The number of compressors n_comp are calculated as","category":"page"},{"location":"nodes/h2_storage/","page":"H₂ storage","title":"H₂ storage","text":"n_comp = ceilleft(fraclog PR_totlog PR_maxright)","category":"page"},{"location":"nodes/h2_storage/","page":"H₂ storage","title":"H₂ storage","text":"in which PR_tot = p_maxp_min and PR_max is a user specified maximum pressure ratio. The utilized pressure ratio is then given as","category":"page"},{"location":"nodes/h2_storage/","page":"H₂ storage","title":"H₂ storage","text":"PR = PR_tot^1n_comp","category":"page"},{"location":"nodes/h2_storage/","page":"H₂ storage","title":"H₂ storage","text":"The required electricity demand for compression is subsequently calculated using the concepts explained on Calculation of compression energy.","category":"page"},{"location":"nodes/h2_storage/","page":"H₂ storage","title":"H₂ storage","text":"The non-linear compression curve is implemented using a piecewise linear approach in which the break points are identified as the inlet to each compressor as well as 1/3 of the pressure ratio in each compressor:","category":"page"},{"location":"nodes/h2_storage/","page":"H₂ storage","title":"H₂ storage","text":"beginaligned\n  hatp_1  = p_min \n  hatp_2i+2  = p_inPR^i  qquad textfor  i in 0 ldots n_comp-1 \n  hatp_2i+3  = left(13PR+23right)p_inPR^i  qquad textfor  i in 0 ldots n_comp-1 \n  hatp_end  = p_max \nendaligned","category":"page"},{"location":"nodes/h2_storage/","page":"H₂ storage","title":"H₂ storage","text":"Given the formulation, it is possible that some pressures are included twice and that the pressures are not sorted. Hence, the hattextbefp is sorted and all duplicates are removed resulting in n_p break points.","category":"page"},{"location":"nodes/h2_storage/","page":"H₂ storage","title":"H₂ storage","text":"The required relative compression energy at each breakpoint hatW_p is then calculated using the function energy_curve as described on Compression train.","category":"page"},{"location":"nodes/h2_storage/","page":"H₂ storage","title":"H₂ storage","text":"The implementation through Special Ordered Sets of Type 2 constraints requires the introduction of an auxiliary variable lambda in 01 which is indexed over all operational periods t in T and all break points given by 1 ldots n_p. The required constraints are subsequently given by","category":"page"},{"location":"nodes/h2_storage/","page":"H₂ storage","title":"H₂ storage","text":"beginaligned\ntextttstor_leveln t  =\n  sum_i in 1 ldots n_p lambdat ifrachatp_i-p_minp_max-p_min capacity(level(n) t) \nW_pt  = sum_i in 1 ldots n_p lambdat i hatW_pi\nendaligned","category":"page"},{"location":"nodes/h2_storage/","page":"H₂ storage","title":"H₂ storage","text":"The first constraints link the storage level at each operational period to the pressure p through a piecewise linear interpolation utilizing the variables lambdat  and hattextbfp while the second constraints calculate the required compression electricity demand W_pt through a piecewise linear interpolation utilizing the variables lambdat  and hattextbfW.","category":"page"},{"location":"nodes/h2_storage/","page":"H₂ storage","title":"H₂ storage","text":"In addition, we have to declare","category":"page"},{"location":"nodes/h2_storage/","page":"H₂ storage","title":"H₂ storage","text":"beginaligned\nsum_i in 1 ldots n_p lambdat i  = 1 \nlambdat   in SOS2()\nendaligned","category":"page"},{"location":"nodes/h2_storage/","page":"H₂ storage","title":"H₂ storage","text":"The first constraint assures a proper linear interpolation between break points while the second constraint states that only 2 of the variables lambdat  can be non-zero. In addition, if two variables are non-zero, they have to be sequential.","category":"page"},{"location":"aux-fun/pressure_calc/#aux-p_calc","page":"Compression energy","title":"Calculation of compression energy","text":"","category":"section"},{"location":"aux-fun/pressure_calc/#aux-p_calc-single","page":"Compression energy","title":"Single compressor","text":"","category":"section"},{"location":"aux-fun/pressure_calc/","page":"Compression energy","title":"Compression energy","text":"The pressure increase through compression can be either isothermal, polytropic, or isentropic. The required energy for compression increases from isothermal to isentropic. EnergyModelsHydrogen incorporates isentropic compression. Depending on the input parameters, this can however be translated to polytropic compression. In the following, ideal gas behaviour is assumed.","category":"page"},{"location":"aux-fun/pressure_calc/","page":"Compression energy","title":"Compression energy","text":"Given the ideal gas constant R (8.314 J/mol/K), the inlet temperature T_1 (in K), the specific heat ratio kappa (no unit), the efficiency eta (no unit), the inlet pressure p_1, and the outlet pressure p_2 (both pressures require the same unit), the compression energy W_p in J/mol can be calculated as","category":"page"},{"location":"aux-fun/pressure_calc/","page":"Compression energy","title":"Compression energy","text":"W_p(p_1 p_2) =\n    frackappa R T_1kappa-1\n    left(left(fracp_2p_1right)^frackappa-1kappa-1right)\n    frac1eta","category":"page"},{"location":"aux-fun/pressure_calc/","page":"Compression energy","title":"Compression energy","text":"The compression energy requirement is implemented through the function compression_energy. This function requires as default only the pressures p_1 and p_2 while all other parameters can be included as keyword arguments. The included standard values are T_1=29815textK, kappa = 141, and eta = 075. This values are representative for hydrogen.","category":"page"},{"location":"aux-fun/pressure_calc/#aux-p_calc-train","page":"Compression energy","title":"Compression train","text":"","category":"section"},{"location":"aux-fun/pressure_calc/","page":"Compression energy","title":"Compression energy","text":"It is in general not advisable to have a large compression ratio as the temperature increase results in an increased compression energy requirment. It is instead beneficial to utilize multiple compressors with interstage cooling.","category":"page"},{"location":"aux-fun/pressure_calc/","page":"Compression energy","title":"Compression energy","text":"If the delivery pressure p is larger than the inlet pressure p_in, we first calculate the different pressure levels for a compressor traing of n_comp compressors and a maximum pressure ratio of PR in each compressor as","category":"page"},{"location":"aux-fun/pressure_calc/","page":"Compression energy","title":"Compression energy","text":"beginaligned\np_i+11  = p_in PR^i quad textfor  i in 0 ldots n_comp-1 quad  textif  p  p_inPR^i \np_i2  = p_in PR^i quad textfor  i in 1 ldots n_comp quad  textif  p  p_inPR^i \nendaligned","category":"page"},{"location":"aux-fun/pressure_calc/","page":"Compression energy","title":"Compression energy","text":"As can be seen from above equations, we have one more pressure p_i1 than p_i2. Hence, the pressure p is added to p_i2.","category":"page"},{"location":"aux-fun/pressure_calc/","page":"Compression energy","title":"Compression energy","text":"The total compression energy requirement (without unit, as fraction of the stored energy) is then given by","category":"page"},{"location":"aux-fun/pressure_calc/","page":"Compression energy","title":"Compression energy","text":"W = fracsum_i W_p(p_i1 p_i2)1000 M times textLHV","category":"page"},{"location":"aux-fun/pressure_calc/","page":"Compression energy","title":"Compression energy","text":"using the molar mass M (in g/mol) and the lower heating value LHV (in MJ/kg).","category":"page"},{"location":"aux-fun/pressure_calc/","page":"Compression energy","title":"Compression energy","text":"The energy demand in a compressor train is implemented through the function energy_curve.","category":"page"},{"location":"aux-fun/lin-reform/#aux-lin_reform","page":"Linear reformulation","title":"Linear reformulation","text":"","category":"section"},{"location":"aux-fun/lin-reform/#aux-lin_reform-bin_con","page":"Linear reformulation","title":"Product of continuous and binary variable","text":"","category":"section"},{"location":"aux-fun/lin-reform/#aux-lin_reform-bin_con-gen","page":"Linear reformulation","title":"General approach","text":"","category":"section"},{"location":"aux-fun/lin-reform/","page":"Linear reformulation","title":"Linear reformulation","text":"Consider the product z between a continuous variable x and a binary variable y with x being constrained as x in lb ub. In this case, it is possible to reformulate the product through linear inequality constraints:","category":"page"},{"location":"aux-fun/lin-reform/","page":"Linear reformulation","title":"Linear reformulation","text":"beginaligned\nlb times y leq  z leq ub times y \nub (y-1) + x leq  z leq lb (1-y) + x\nendaligned","category":"page"},{"location":"aux-fun/lin-reform/","page":"Linear reformulation","title":"Linear reformulation","text":"The first line enforces that if y = 1, then z in lb ub, otherwise, z = 0. The second line enforces that z = x if y = 1. The constraint is inactive if y = 0.","category":"page"},{"location":"aux-fun/lin-reform/#aux-lin_reform-bin_con-idx","page":"Linear reformulation","title":"Indexing in EnergyModelsHydrogen","text":"","category":"section"},{"location":"aux-fun/lin-reform/","page":"Linear reformulation","title":"Linear reformulation","text":"EnergyModelsHydrogen provides two functions for the linear reformulation which differ with respect to the indexing of the individual variables. It would be also possible to include the indexing within the function call, but it is preferable to create the anonymous auxiliary variables within a single call.","category":"page"},{"location":"aux-fun/lin-reform/","page":"Linear reformulation","title":"Linear reformulation","text":"These two functions differ in the time structure indexing. Mathematically, this is given as","category":"page"},{"location":"aux-fun/lin-reform/","page":"Linear reformulation","title":"Linear reformulation","text":"zt = xt times bt and\nzt_a t_b = xt_b times bt_a t_b.","category":"page"},{"location":"aux-fun/lin-reform/","page":"Linear reformulation","title":"Linear reformulation","text":"The linear reformulations are available through the function EnergyModelsHydrogen.linear_reformulation()","category":"page"},{"location":"aux-fun/lin-reform/#aux-lin_reform-bin_bin","page":"Linear reformulation","title":"Product of two binary variablees","text":"","category":"section"},{"location":"aux-fun/lin-reform/","page":"Linear reformulation","title":"Linear reformulation","text":"The element-wise product z of n binary variables x_i, that is","category":"page"},{"location":"aux-fun/lin-reform/","page":"Linear reformulation","title":"Linear reformulation","text":"z = prod_i=1^n x_i","category":"page"},{"location":"aux-fun/lin-reform/","page":"Linear reformulation","title":"Linear reformulation","text":"can be reformulated as","category":"page"},{"location":"aux-fun/lin-reform/","page":"Linear reformulation","title":"Linear reformulation","text":"beginaligned\nz  leq x_i qquadqquadqquad textfor  i = 1ldotsn \nz  geq sum_i=1^n x_i - (n-1)\nendaligned","category":"page"},{"location":"aux-fun/lin-reform/","page":"Linear reformulation","title":"Linear reformulation","text":"This reformulation is exact.","category":"page"},{"location":"library/internals/methods-fields/#lib-int-met_field","page":"Methods - Accessing fields","title":"Methods - Accessing fields","text":"","category":"section"},{"location":"library/internals/methods-fields/#lib-int-met_field-idx","page":"Methods - Accessing fields","title":"Index","text":"","category":"section"},{"location":"library/internals/methods-fields/","page":"Methods - Accessing fields","title":"Methods - Accessing fields","text":"Pages = [\"methods-fields.md\"]","category":"page"},{"location":"library/internals/methods-fields/#lib-int-met_field-elec","page":"Methods - Accessing fields","title":"AbstractElectrolyzer types","text":"","category":"section"},{"location":"library/internals/methods-fields/","page":"Methods - Accessing fields","title":"Methods - Accessing fields","text":"EnergyModelsHydrogen.degradation_rate\nEnergyModelsHydrogen.stack_replacement_cost\nEnergyModelsHydrogen.stack_lifetime","category":"page"},{"location":"library/internals/methods-fields/#EnergyModelsHydrogen.degradation_rate","page":"Methods - Accessing fields","title":"EnergyModelsHydrogen.degradation_rate","text":"degradation_rate(n::Electrolyzer)\n\nReturns the degradation rate of electrolyzer n.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-fields/#EnergyModelsHydrogen.stack_replacement_cost","page":"Methods - Accessing fields","title":"EnergyModelsHydrogen.stack_replacement_cost","text":"stack_replacement_cost(n::Electrolyzer)\nstack_replacement_cost(n::Electrolyzer, t_inv)\n\nReturns the stack replacement costs of electrolyzer n as TimeProfile or in strategic period t_inv.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-fields/#EnergyModelsHydrogen.stack_lifetime","page":"Methods - Accessing fields","title":"EnergyModelsHydrogen.stack_lifetime","text":"stack_lifetime(n::Electrolyzer)\n\nReturns the stack lfetime of electrolyzer n.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-fields/#lib-int-met_field-ref","page":"Methods - Accessing fields","title":"AbstractReformer types","text":"","category":"section"},{"location":"library/internals/methods-fields/","page":"Methods - Accessing fields","title":"Methods - Accessing fields","text":"EnergyModelsHydrogen.opex_startup\nEnergyModelsHydrogen.opex_shutdown\nEnergyModelsHydrogen.opex_off\nEnergyModelsHydrogen.time_startup\nEnergyModelsHydrogen.time_shutdown\nEnergyModelsHydrogen.time_off\nEnergyModelsHydrogen.ramp_limit","category":"page"},{"location":"library/internals/methods-fields/#EnergyModelsHydrogen.opex_startup","page":"Methods - Accessing fields","title":"EnergyModelsHydrogen.opex_startup","text":"opex_startup(n::AbstractReformer)\nopex_startup(n::AbstractReformer, t)\n\nReturns the startup OPEX of AbstractReformer n as TimeProfile or in in operational period t.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-fields/#EnergyModelsHydrogen.opex_shutdown","page":"Methods - Accessing fields","title":"EnergyModelsHydrogen.opex_shutdown","text":"opex_shutdown(n::AbstractReformer)\nopex_shutdown(n::AbstractReformer, t)\n\nReturns the shutdown OPEX of AbstractReformer n as TimeProfile or in in operational period t.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-fields/#EnergyModelsHydrogen.opex_off","page":"Methods - Accessing fields","title":"EnergyModelsHydrogen.opex_off","text":"opex_off(n::AbstractReformer)\nopex_off(n::AbstractReformer, t)\n\nReturns the offline OPEX of AbstractReformer n as TimeProfile or in in operational period t.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-fields/#EnergyModelsHydrogen.time_startup","page":"Methods - Accessing fields","title":"EnergyModelsHydrogen.time_startup","text":"time_startup(n::AbstractReformer)\ntime_startup(n::AbstractReformer, t)\n\nReturns the minimum startup time of AbstractReformer n as TimeProfile or in in operational period t.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-fields/#EnergyModelsHydrogen.time_shutdown","page":"Methods - Accessing fields","title":"EnergyModelsHydrogen.time_shutdown","text":"time_shutdown(n::AbstractReformer)\ntime_shutdown(n::AbstractReformer, t)\n\nReturns the minimum shutdown time of AbstractReformer n as TimeProfile or in in operational period t.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-fields/#EnergyModelsHydrogen.time_off","page":"Methods - Accessing fields","title":"EnergyModelsHydrogen.time_off","text":"time_off(n::AbstractReformer)\ntime_off(n::AbstractReformer, t)\n\nReturns the minimum offline time of AbstractReformer n as TimeProfile or in in operational period t.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-fields/#EnergyModelsHydrogen.ramp_limit","page":"Methods - Accessing fields","title":"EnergyModelsHydrogen.ramp_limit","text":"ramp_limit(n::AbstractReformer)\n\nReturns the AbstractRampParameters type of AbstractReformer n.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-fields/#lib-int-met_field-abst_h2_stor","page":"Methods - Accessing fields","title":"AbstractH2Storage types","text":"","category":"section"},{"location":"library/internals/methods-fields/","page":"Methods - Accessing fields","title":"Methods - Accessing fields","text":"EnergyModelsHydrogen.discharge_charge\nEnergyModelsHydrogen.level_charge","category":"page"},{"location":"library/internals/methods-fields/#EnergyModelsHydrogen.discharge_charge","page":"Methods - Accessing fields","title":"EnergyModelsHydrogen.discharge_charge","text":"discharge_charge(n::AbstractH2Storage)\n\nReturns the discharge to charge ratio of AbstractH2Storage n.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-fields/#EnergyModelsHydrogen.level_charge","page":"Methods - Accessing fields","title":"EnergyModelsHydrogen.level_charge","text":"level_charge(n::AbstractH2Storage)\n\nReturns the level to charge ratio of AbstractH2Storage n.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-fields/#lib-int-met_field-h2_stor","page":"Methods - Accessing fields","title":"HydrogenStorage types","text":"","category":"section"},{"location":"library/internals/methods-fields/","page":"Methods - Accessing fields","title":"Methods - Accessing fields","text":"EnergyModelsHydrogen.p_charge\nEnergyModelsHydrogen.p_min\nEnergyModelsHydrogen.p_max\nEnergyModelsHydrogen.electricity_resource","category":"page"},{"location":"library/internals/methods-fields/#EnergyModelsHydrogen.p_charge","page":"Methods - Accessing fields","title":"EnergyModelsHydrogen.p_charge","text":"p_charge(n::HydrogenStorage)\n\nReturns the charging pressure of HydrogenStorage, n. This pressure corresponds to the inlet pressure of the node, that is the pressure used for calculating the energy demand.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-fields/#EnergyModelsHydrogen.p_min","page":"Methods - Accessing fields","title":"EnergyModelsHydrogen.p_min","text":"p_min(n::HydrogenStorage)\n\nReturns the minimum pressure of HydrogenStorage, n. This pressure corresponds to an empty storage.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-fields/#EnergyModelsHydrogen.p_max","page":"Methods - Accessing fields","title":"EnergyModelsHydrogen.p_max","text":"p_max(n::HydrogenStorage)\n\nReturns the maximum pressure of HydrogenStorage, n. This pressure corresponds to a full storage.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-fields/#EnergyModelsHydrogen.electricity_resource","page":"Methods - Accessing fields","title":"EnergyModelsHydrogen.electricity_resource","text":"el_res(n::HydrogenStorage)\n\nReturns the resource of HydrogenStorage, n which corresponds to electricity in the system.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-fields/#lib-int-met_field-loadlim","page":"Methods - Accessing fields","title":"LoadLimit and Node types","text":"","category":"section"},{"location":"library/internals/methods-fields/","page":"Methods - Accessing fields","title":"Methods - Accessing fields","text":"EnergyModelsHydrogen.min_load\nEnergyModelsHydrogen.max_load","category":"page"},{"location":"library/internals/methods-fields/#EnergyModelsHydrogen.min_load","page":"Methods - Accessing fields","title":"EnergyModelsHydrogen.min_load","text":"min_load(load_lim::AbstractLoadLimits)\nmin_load(load_lim::AbstractLoadLimits, t)\n\nReturns the minimum load of AbstractLoadLimits load_lim as TimeProfile or in operational period t.\n\nnote: Note\nThe default LoadLimits does not allow for time dependent load limits. In this case, the function returns a FixedProfile of the provided value.\n\n\n\n\n\nmin_load(n::EMB.Node)\nmin_load(n::EMB.Node, t)\n\nReturns the minimum load of Node n as TimeProfile or in operational period t.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-fields/#EnergyModelsHydrogen.max_load","page":"Methods - Accessing fields","title":"EnergyModelsHydrogen.max_load","text":"max_load(load_lim::AbstractLoadLimits)\nmin_load(load_lim::AbstractLoadLimits, t)\n\nReturns the maximum load of AbstractLoadLimits load_lim as TimeProfile or in operational period t.\n\nnote: Note\nThe default LoadLimits does not allow for time dependent load limits. In this case, the function returns a FixedProfile of the provided value.\n\n\n\n\n\nmax_load(n::EMB.Node)\nmax_load(n::EMB.Node, t)\n\nReturns the maximum load of Node n.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-fields/#lib-int-met_field-ramp","page":"Methods - Accessing fields","title":"AbstractRampParameters and AbstractReformer types","text":"","category":"section"},{"location":"library/internals/methods-fields/","page":"Methods - Accessing fields","title":"Methods - Accessing fields","text":"EnergyModelsHydrogen.ramp_up\nEnergyModelsHydrogen.ramp_down","category":"page"},{"location":"library/internals/methods-fields/#EnergyModelsHydrogen.ramp_up","page":"Methods - Accessing fields","title":"EnergyModelsHydrogen.ramp_up","text":"ramp_up(ramp_param::UnionRampUp)\nramp_up(ramp_param::UnionRampUp, t)\n\nReturns the maximum positive rate of change of UnionRampUp ramp_param as TimeProfile or in operational period t.\n\n\n\n\n\nramp_up(n::AbstractReformer)\nramp_up(n::AbstractReformer, t)\n\nReturns the maximum positive rate of change of AbstractReformer n as TimeProfile or in operational period t.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-fields/#EnergyModelsHydrogen.ramp_down","page":"Methods - Accessing fields","title":"EnergyModelsHydrogen.ramp_down","text":"ramp_down(ramp_param::UnionRampDown)\nramp_down(ramp_param::UnionRampDown, t)\n\nReturns the maximum negative rate of change of UnionRampDown ramp_param as TimeProfile or in operational period t.\n\n\n\n\n\nramp_down(n::AbstractReformer)\nramp_down(n::AbstractReformer, t)\n\nReturns the maximum negative rate of change of AbstractReformer n as TimeProfile or in operational period t.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-fields/#lib-int-met_field-commit","page":"Methods - Accessing fields","title":"CommitParameters types","text":"","category":"section"},{"location":"library/internals/methods-fields/","page":"Methods - Accessing fields","title":"Methods - Accessing fields","text":"EnergyModelsHydrogen.opex_state\nEnergyModelsHydrogen.time_state","category":"page"},{"location":"library/internals/methods-fields/#EnergyModelsHydrogen.opex_state","page":"Methods - Accessing fields","title":"EnergyModelsHydrogen.opex_state","text":"opex_state(com_par::CommitParameters)\nopex_state(com_par::CommitParameters, t)\n\nReturns the unit commitment OPEX as TimeProfile or in operational period t.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-fields/#EnergyModelsHydrogen.time_state","page":"Methods - Accessing fields","title":"EnergyModelsHydrogen.time_state","text":"time_state(com_par::CommitParameters)\ntime_state(com_par::CommitParameters, t)\n\nReturns the minimum time in the state as TimeProfile or in operational period t.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-fields/#lib-int-met_field-elec_per","page":"Methods - Accessing fields","title":"ElecPeriods types","text":"","category":"section"},{"location":"library/internals/methods-fields/","page":"Methods - Accessing fields","title":"Methods - Accessing fields","text":"TimeStruct.strat_periods\nEnergyModelsHydrogen.strat_per\nEnergyModelsHydrogen.op_per\nEnergyModelsHydrogen.is_last","category":"page"},{"location":"library/internals/methods-fields/#TimeStruct.strat_periods","page":"Methods - Accessing fields","title":"TimeStruct.strat_periods","text":"TS.strat_periods(pers::ElecPeriods)\n\nReturns the strategic periods of an ElecPeriods pers.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-fields/#EnergyModelsHydrogen.strat_per","page":"Methods - Accessing fields","title":"EnergyModelsHydrogen.strat_per","text":"strat_per(pers::ElecPeriods)\n\nReturns the current strategic period of an ElecPeriods pers.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-fields/#EnergyModelsHydrogen.op_per","page":"Methods - Accessing fields","title":"EnergyModelsHydrogen.op_per","text":"op_per(pers::ElecPeriods)\n\nReturns the current operational period of an ElecPeriods pers.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-fields/#EnergyModelsHydrogen.is_last","page":"Methods - Accessing fields","title":"EnergyModelsHydrogen.is_last","text":"is_last(pers::ElecPeriods)\n\nBoolean indicator whether the representative period or operational scenario is the last within a strategic period of an ElecPeriods pers.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-fields/#lib-int-met_field-ref_per","page":"Methods - Accessing fields","title":"RefPeriods types","text":"","category":"section"},{"location":"library/internals/methods-fields/","page":"Methods - Accessing fields","title":"Methods - Accessing fields","text":"EnergyModelsHydrogen.prev_op\nEnergyModelsHydrogen.current_op\nEnergyModelsHydrogen.last_op","category":"page"},{"location":"library/internals/methods-fields/#EnergyModelsHydrogen.prev_op","page":"Methods - Accessing fields","title":"EnergyModelsHydrogen.prev_op","text":"prev_op(pers::RefPeriods)\n\nReturns the previous operational period of a RefPeriods pers.\n\n\n\n\n\nWhen the previous operational period is nothing, it returns the last operational period within the given time structure.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-fields/#EnergyModelsHydrogen.current_op","page":"Methods - Accessing fields","title":"EnergyModelsHydrogen.current_op","text":"current_op(pers::RefPeriods)\n\nReturns the current operational period of a RefPeriods pers.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/methods-fields/#EnergyModelsHydrogen.last_op","page":"Methods - Accessing fields","title":"EnergyModelsHydrogen.last_op","text":"last_op(pers::RefPeriods)\n\nReturns the last operational period of a RefPeriods pers.\n\n\n\n\n\n","category":"function"},{"location":"manual/NEWS/#Release-Notes","page":"Release notes","title":"Release Notes","text":"","category":"section"},{"location":"manual/NEWS/#Version-0.8.0-(2024-12-05)","page":"Release notes","title":"Version 0.8.0 (2024-12-05)","text":"","category":"section"},{"location":"manual/NEWS/#Rework-of-stack-replacement","page":"Release notes","title":"Rework of stack replacement","text":"","category":"section"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"Replaced the formulation in stack replacement with an approach reducing the number of binary variables.\nThe approach is equivalent to the previous with respect to the results.\nThe documentation is updated with the new formulation.","category":"page"},{"location":"manual/NEWS/#Hydrogen-storage","page":"Release notes","title":"Hydrogen storage","text":"","category":"section"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"Developed two nodes for hydrogen storage:\nSimpleHydrogenStorage incorporates a constraint on the maximum discharge through a multiplier of the charge capacity as well as providing an upper bound for the maximum charge capacity as a function of the storage level capacity.\nHydrogenStorage includes a storage level dependent term for the compression electricity requirement using a piecewise linear representation of the non-linear compression curves through SOS2 constraints and a bilinear term.\nInvestment are not possible for this node.\nIncluded checks, documentations, and tests for both nodes.\nIncluded an example for HydrogenStorage.","category":"page"},{"location":"manual/NEWS/#Misc","page":"Release notes","title":"Misc","text":"","category":"section"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"Split file constraint_functions.jl:\nconstraint/general.jl for methods dispatching on EnergyModelsBase constraints,\nconstraint/electrolyzer.jl for functions introduced for AbstractElectrolyzer types, and\nconstraint/reformer.jl for functions introduced for Reformer nodes.\nUpdated the checks with the new functionality from EnergyModelsBase v0.8.3.\nIncluded a how to contribute section to documentation.","category":"page"},{"location":"manual/NEWS/#Version-0.7.3-(2024-11-11)","page":"Release notes","title":"Version 0.7.3 (2024-11-11)","text":"","category":"section"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"Fixed a bug when providing a lower bound in linear refomulation enforcing in this case 100 % usage of the node.\nAdded tests for linear reformulation to avoid any future issues.","category":"page"},{"location":"manual/NEWS/#Version-0.7.2-(2024-11-03)","page":"Release notes","title":"Version 0.7.2 (2024-11-03)","text":"","category":"section"},{"location":"manual/NEWS/#Enhancement","page":"Release notes","title":"Enhancement","text":"","category":"section"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"Provide the correct lower and upper bounds for the lienar reformulation.","category":"page"},{"location":"manual/NEWS/#Bugfix","page":"Release notes","title":"Bugfix","text":"","category":"section"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"Reverted change included in 0.7.0 point 2 as the previous implementation was after all correct.\nThe error did not have any impact on the results if the lower bound was specified as larger than 0. It would however impact the linear relaxation as the constraints were not as tight.","category":"page"},{"location":"manual/NEWS/#Version-0.7.1-(2024-10-24)","page":"Release notes","title":"Version 0.7.1 (2024-10-24)","text":"","category":"section"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"Included new examples for both reformer and electrolysis.\nMinor updates on docstrings and descriptions.\nAdjusted to EnergyModelsBase v0.8.1.","category":"page"},{"location":"manual/NEWS/#Version-0.7.0-(2024-08-02)","page":"Release notes","title":"Version 0.7.0 (2024-08-02)","text":"","category":"section"},{"location":"manual/NEWS/#Feature-Ramping","page":"Release notes","title":"Feature - Ramping","text":"","category":"section"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"Added rate of change constraints for reformer to limit its change within a given time.\nThe constraint is only active if the reformer is not switching state through implementation of a disjunction.\nIt is possible to only limit the positive or negative utilization change through the application of AbstractRampParameters.","category":"page"},{"location":"manual/NEWS/#Documentation","page":"Release notes","title":"Documentation","text":"","category":"section"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"Added external references to refer to types and methods from EnergyModelsBase.\nSignificantly improved the documentation through inclusion of the mathematical descriptions for the individual nodes as well as restructuring the library.","category":"page"},{"location":"manual/NEWS/#Enhancement-2","page":"Release notes","title":"Enhancement","text":"","category":"section"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"Rewrote the dynamic constraints for improved potential for extensions with differing time structures and in preparation for a receding horizon framework.\nMoved the load limits to a separate type for a reduced number of input of the different Nodes.\nMoved the unit commitment parameters to a separate type for a reduced number of input of the different Nodes.\nReduced lines in test of checks.","category":"page"},{"location":"manual/NEWS/#Bugfix-2","page":"Release notes","title":"Bugfix","text":"","category":"section"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"Fixed a bug in a system with investments in which the initial valus for the Electrolyzer binaries were not properly applied. This appraoch lead to non-investments in electrolysis.\nFixed an error in the function linear_reformulation regarding:\nThe indexing of the bounds was wrong if the resulting variable is indexed over two time levels\nOne of the constraints would result in wrong values if a lower bound was specified.\nThe bugs in linear_reformulation did not affect our results as we specified a lower bound of 0 and and a `FixedProfile for bounds.\nFixed a bug in the checks for the degradation_rate of AbstractElectrolyzer nodes.","category":"page"},{"location":"manual/NEWS/#Version-0.6.2-(2024-07-24)","page":"Release notes","title":"Version 0.6.2 (2024-07-24)","text":"","category":"section"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"Added checks and tests of the checks for both AbstractElectrolyzer and AbstractReformer.","category":"page"},{"location":"manual/NEWS/#Version-0.6.1-(2024-07-23)","page":"Release notes","title":"Version 0.6.1 (2024-07-23)","text":"","category":"section"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"Moved EnergyModelsInvestments extension to a separate subfolder in the extension folder.","category":"page"},{"location":"manual/NEWS/#Version-0.6.0-(2024-07-23)","page":"Release notes","title":"Version 0.6.0 (2024-07-23)","text":"","category":"section"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"Adjusted to changes introduced in TimeStruct v0.8 (and correspondingly EnergyModelsBase v0.7 and EnergyModelsInvestments v0.6).","category":"page"},{"location":"manual/NEWS/#Implementation-of-Reformer-node","page":"Release notes","title":"Implementation of Reformer node","text":"","category":"section"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"Reformer work as unit commitment nodes with minimum time for startup, shutdown and offline states with associated costs.\nThe initial version is based on the work of Erik Svendsmark for the startup shutdown technology.\nThe work was extended based on new available features in TimeStruct (namely chunk and chunk_duration).\nIn addition, the introduced costs are now dependent on the installed capacity.","category":"page"},{"location":"manual/NEWS/#Version-0.5.2-(2024-04-03)","page":"Release notes","title":"Version 0.5.2 (2024-04-03)","text":"","category":"section"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"Fixed a bug when utilizing representative periods.\nAdded a function for fixing the binary variables in periods they do not change.","category":"page"},{"location":"manual/NEWS/#Version-0.5.1-(2024-02-16)","page":"Release notes","title":"Version 0.5.1 (2024-02-16)","text":"","category":"section"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"Introduced a new type SimpleElectrolyzer to implement stack degradation and minimum operational point without the penalty of the bilinear term.\nAdd EnergyModelsInvestments as weak dependency to avoid cration of unnecessary variables for the reformulation of the bilinear terms.\nIntroduced utilities that can be used for the bilinear reformulation.","category":"page"},{"location":"manual/NEWS/#Version-0.5.0-(2024-02-14)","page":"Release notes","title":"Version 0.5.0 (2024-02-14)","text":"","category":"section"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"Adjusted to changes introduced throuch EnergyModelsBase v0.6.\nRepresentative periods in TimeStruct are now included for the calculation of the efficiency penalty.","category":"page"},{"location":"manual/NEWS/#Version-0.4.0-(2023-06-02)","page":"Release notes","title":"Version 0.4.0 (2023-06-02)","text":"","category":"section"},{"location":"manual/NEWS/#Switch-to-TimeStruct.jl","page":"Release notes","title":"Switch to TimeStruct.jl","text":"","category":"section"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"Switched the time structure representation to TimeStruct.\nTimeStruct is implemented with only the basis features that were available in TimesStructures.jl. This implies that neither operational nor strategic uncertainty is included in the model.","category":"page"},{"location":"manual/NEWS/#Version-0.3.0-(2023-05-31)","page":"Release notes","title":"Version 0.3.0 (2023-05-31)","text":"","category":"section"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"Adjustment to changes in EnergyModelsBase v0.4.0 related to extra input data.","category":"page"},{"location":"manual/NEWS/#Version-0.2.1-(2023-05-15)","page":"Release notes","title":"Version 0.2.1 (2023-05-15)","text":"","category":"section"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"Adjustment to changes in EnergyModelsBase v0.3.3 related to the calls for the constraint functions.","category":"page"},{"location":"manual/NEWS/#Version-0.2.0-(2023-02-03)","page":"Release notes","title":"Version 0.2.0 (2023-02-03)","text":"","category":"section"},{"location":"manual/NEWS/#Adjustmends-to-updates-in-EnergyModelsBase","page":"Release notes","title":"Adjustmends to updates in EnergyModelsBase","text":"","category":"section"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"Adjustment to version EnergyModelsBase 0.3.0, namely:","category":"page"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"The removal of emissions from Node type definition that do not require them. In this case, this is the type Electrolyzer and all tests.\nAdjustment of the changes in the call of variables_node.\nUtlization of the new function calls for constraint generations.\nRemoval of the type GlobalData and replacement with fields in the type OperationalModel in all tests.","category":"page"},{"location":"manual/NEWS/#Version-0.1.3-(2023-01-13)","page":"Release notes","title":"Version 0.1.3 (2023-01-13)","text":"","category":"section"},{"location":"manual/NEWS/#Bug-fixes","page":"Release notes","title":"Bug fixes","text":"","category":"section"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"Fixed a bug, that required stack replacement in all years after the initial stack replacement.","category":"page"},{"location":"manual/NEWS/#Version-0.1.2-(2023-01-10)","page":"Release notes","title":"Version 0.1.2 (2023-01-10)","text":"","category":"section"},{"location":"manual/NEWS/#Bug-fixes-2","page":"Release notes","title":"Bug fixes","text":"","category":"section"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"Fixed a bug that forces the electrolyser to operate when the parameter Minimum_load was not equal to 0.","category":"page"},{"location":"manual/NEWS/#Version-0.1.1-(2022-12-12)","page":"Release notes","title":"Version 0.1.1 (2022-12-12)","text":"","category":"section"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"Updated Readme.","category":"page"},{"location":"manual/NEWS/#Version-0.1.0-(2022)","page":"Release notes","title":"Version 0.1.0 (2022)","text":"","category":"section"},{"location":"manual/NEWS/","page":"Release notes","title":"Release notes","text":"Initial version.","category":"page"},{"location":"#EnergyModelsHydrogen","page":"Home","title":"EnergyModelsHydrogen","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"EnergyModelsHydrogen","category":"page"},{"location":"#EnergyModelsHydrogen","page":"Home","title":"EnergyModelsHydrogen","text":"Main module for EnergyModelsHydrogen.\n\nThis module implements constraints for describing electrolysis through the types SimpleElectrolyzer and Electrolyzer, natural gas reforming through the type Reformer, and Hydrogen storage through the types SimpleHydrogenStorage and HydrogenStorage.\n\n\n\n\n\n","category":"module"},{"location":"","page":"Home","title":"Home","text":"This Julia package implements three main nodes with corresponding JuMP constraints, extending the package EnergyModelsBase with more detailed representation of hydrogen technologies.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The first node is an electrolyser node. Two different types are provided, SimpleElectrolyzer and Electrolyzer. Both types include constraints on the lifetime of the electrolysis stack and the potential for stack replacement. In addition, both types calculate the degradation rate. The Electrolyzer node utilizes the degradation rate to calculate a reducing efficiency resulting in a bilinear problem. The mathematical descriptions can be found on the page Electrolyzer nodes.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The second node is a reformer node described through the type Reformer. The reformer node is incorporating unit commit constraints. The mathematical description can be found on the page Reformer node.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The third node is a hydrogen storage node described through the types SimpleHydrogenStorage and HydrogenStorage. Both types include constraints on the maximum discharge rate relative to the charge capacity and the maximum charge capacity relative to the storage capacity. HydrogenStorage nodes include in addition a dependency of the compression electricity demand on the storage level and the charge rate. The former requires furthermore a piecewise linear formulation for the electricity demand. The mathematical description can be found on the page Hydrogen storage nodes.","category":"page"},{"location":"#Manual-outline","page":"Home","title":"Manual outline","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"manual/quick-start.md\",\n    \"manual/simple-example.md\",\n    \"manual/NEWS.md\",\n]\nDepth = 1","category":"page"},{"location":"#Description-of-the-nodes","page":"Home","title":"Description of the nodes","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"nodes/electrolyzer.md\",\n    \"nodes/reformer.md\",\n    \"nodes/h2_storage.md\",\n]\nDepth = 1","category":"page"},{"location":"#How-to-guides","page":"Home","title":"How to guides","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"how-to/contribute.md\",\n]\nDepth = 1","category":"page"},{"location":"#Auxiliary-functions","page":"Home","title":"Auxiliary functions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"aux-fun/lin-reform.md\",\n    \"aux-fun/pressurce_calc.md\",\n]\nDepth = 1","category":"page"},{"location":"#Library-outline","page":"Home","title":"Library outline","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"library/public.md\",\n    \"library/internals/types-EMH.md\",\n    \"library/internals/methods-fields.md\",\n    \"library/internals/methods-EMH.md\",\n    \"library/internals/methods-EMB.md\",\n]\nDepth = 1","category":"page"},{"location":"library/public/#lib-pub","page":"Public","title":"Public interface","text":"","category":"section"},{"location":"library/public/#lib-pub-nodes","page":"Public","title":"Node types","text":"","category":"section"},{"location":"library/public/#lib-pub-nodes-elect","page":"Public","title":"Electrolyzer nodes","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"SimpleElectrolyzer\nElectrolyzer","category":"page"},{"location":"library/public/#EnergyModelsHydrogen.SimpleElectrolyzer","page":"Public","title":"EnergyModelsHydrogen.SimpleElectrolyzer","text":"SimpleElectrolyzer <: AbstractElectrolyzer\n\nDescription of a simple electrolyzer node with minimum and maximum load as well as stack replacement. Degradation is calculated, but not used for the efficiency calculations.\n\nNew fields compared to NetworkNode: min_load, max_load, degradation_rate, stack_lifetime, and stack_replacement_cost.\n\nFields\n\nid is the name/identifier of the node.\ncap::TimeProfile is the installed capacity.\nopex_var::TimeProfile is the variable operating expense per capacity usage.\nopex_fixed::TimeProfile is the fixed operating expense per installed capacity.\ninput::Dict{<:Resource, <:Real} are the input Resources with conversion value Real.\noutput::Dict{<:Resource, <:Real} are the produced Resources with conversion value Real.\ndata::Vector{Data} is the additional data (e.g. for investments).\nload_limits::LoadLimits are limits on the utilization load of the electrolyser. LoadLimits can provide both lower and upper limits on the actual load.\ndegradation_rate::Real is the percentage drop in efficiency due to degradation in %/1000 h.\nstack_replacement_cost::TimeProfile is the replacement cost of electrolyzer stacks.\nstack_lifetime::Real is the total operational stack life time.\n\nnote: Note\nThe nominal electrolyzer efficiency is captured through the combination of input and output.\nThe fixed and variable operating expenses are always related to installed capacity and its usage. This implies if you define the capacity via the input through a value of 1, then the variable operating expense is calaculated through the required electricity.\nStack replacement can only be done once a strategic period, in the first operational period. The thought process behind is that it would otherwise lead to issues if a strategic period is repeated.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#EnergyModelsHydrogen.Electrolyzer","page":"Public","title":"EnergyModelsHydrogen.Electrolyzer","text":"Electrolyzer <: AbstractElectrolyzer\n\nDescription of an electrolyzer node with minimum and maximum load as well as degredation and stack replacement.\n\nNew fields: min_load, max_load, stack_lifetime, stack_replacement_cost, and degradation_rate.\n\nFields\n\nid is the name/identifier of the node.\ncap::TimeProfile is the installed capacity.\nopex_var::TimeProfile is the variable operating expense per capacity used (through the variable :cap_use).\nopex_fixed::TimeProfile is the fixed operating expense per installed capacity.\ninput::Dict{<:Resource, <:Real} are the input Resources with conversion value Real.\noutput::Dict{<:Resource, <:Real} are the produced Resources with conversion value Real.\ndata::Vector{Data} is the additional data (e.g. for investments).\nload_limits::LoadLimits are limits on the utilization load of the electrolyser. LoadLimits can provide both lower and upper limits on the actual load.\ndegradation_rate::Real is the percentage drop in efficiency due to degradation in %/1000 h.\nstack_replacement_cost::TimeProfile is the replacement cost of electrolyzer stacks.\nstack_lifetime::Real is the total operational stack life time.\n\nnote: Note\nThe nominal electrolyzer efficiency is captured through the combination of input and output.\nThe fixed and variable operating expenses are always related to installed capacity and its usage. This implies if you define the capacity via the input through a value of 1, then the variable operating expense is calaculated through the required electricity.\nStack replacement can only be done once a strategic period, in the first operational period. The thought process behind is that it would otherwise lead to issues if a strategic period is repeated.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#lib-pub-nodes-ref","page":"Public","title":"Reformer nodes","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Reformer","category":"page"},{"location":"library/public/#EnergyModelsHydrogen.Reformer","page":"Public","title":"EnergyModelsHydrogen.Reformer","text":"Reformer <: AbstractReformer\n\nA network node with start-up and shut-down time and costs that should be used for reformer technology descriptions.\n\nFields\n\nid is the name/identifier of the node.\ncap::TimeProfile is the installed capacity.\nopex_var::TimeProfile is the variable operating expense per capacity usage.\nopex_fixed::TimeProfile is the fixed operating expense per installed capacity.\ninput::Dict{<:Resource, <:Real} are the input Resources with conversion value Real.\noutput::Dict{<:Resource, <:Real} are the produced Resources with conversion value Real.\ndata::Array{Data} is an array of additional data (e.g., for investments).\nload_limits::LoadLimits are limits on the utilization load of the electrolyser. LoadLimits can provide both lower and upper limits on the actual load.\nstartup::CommitParameters are parameters for the startup state constraints.\nshutdown::CommitParameters are parameters for the shutdown state constraints.\noffline::CommitParameters are parameters for the offline state constraints.\nramp_limit::AbstractRampParameters are the limit on the allowable change in the capacity usage.\n\nnote: Note\nIf you introduce CO₂ capture through the application of CaptureEnergyEmissions, you have to add your CO₂ instance as output. The reason for this is that we declare the variable :output through the output dictionary.\nThe specified startup, shutdown, and offline costs are relative to the installed capacity and a duration of 1 of an operational period.\nThe rate limit is relative to the installed capacity and a duration of 1 of an operational period.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#lib-pub-nodes-h2_stor","page":"Public","title":"Hydrogen storage nodes","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"SimpleHydrogenStorage\nHydrogenStorage","category":"page"},{"location":"library/public/#EnergyModelsHydrogen.SimpleHydrogenStorage","page":"Public","title":"EnergyModelsHydrogen.SimpleHydrogenStorage","text":"SimpleHydrogenStorage{T} <: AbstractH2Storage{T}\n\nStorage node in which the maximum discharge usage is directly linked to the charge capacity, that is it is not possbible to have a larger discharge usage than the charge capacity and a multiplier discharge_charge.\n\nFields\n\nid is the name/identifier of the node.\ncharge::EMB.UnionCapacity are the charging parameters of the SimpleHydrogenStorage node. Depending on the chosen type, the charge parameters can include variable OPEX, fixed OPEX, and/or a capacity.\nlevel::EMB.UnionCapacity are the level parameters of the SimpleHydrogenStorage node. Depending on the chosen type, the charge parameters can include variable OPEX and/or fixed OPEX.\nstor_res::Resource is the stored Resource.\ninput::Dict{<:Resource, <:Real} are the input Resources with conversion value Real.\noutput::Dict{<:Resource, <:Real} are the generated Resources with conversion value Real. Only relevant for linking and the stored Resource as the output value is not utilized in the calculations.\ndata::Vector{<:Data} is the additional data (e.g., for investments). The field data is conditional through usage of a constructor.\ndischarge_charge::Float64 is the multiplier for specifying the maximum discharge rate relative to the charge rate. A value of 2.0 would imply that it is possible to have double the discharge rate compared to the installed charge capacity.\nlevel_charge::Float64 is the multiplier for specifying the installed storage level capacity relative to the installed storage charge capacity. It is used for checking input data in the case of a generic model and for limiting investments in the case of an AbstractInvestmentModel.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#EnergyModelsHydrogen.HydrogenStorage","page":"Public","title":"EnergyModelsHydrogen.HydrogenStorage","text":"HydrogenStorage{T} <: AbstractH2Storage{T}\n\nStorage node in which the maximum discharge usage is directly linked to the charge capacity, that is it is not possbible to have a larger discharge usage than the charge capacity and a multiplier discharge_charge.\n\nIt differs from SimpleHydrogenStorage through incorporation of a piecewise linear curve for the electricity demand, depending on the current storage level and the defined upper (field p_max) and charge pressure (field p_charge) of the node.\n\nFields\n\nid is the name/identifier of the node.\ncharge::EMB.UnionCapacity are the charging parameters of the SimpleHydrogenStorage node. Depending on the chosen type, the charge parameters can include variable OPEX, fixed OPEX, and/or a capacity.\nstor_res::Resource is the stored Resource.\nel_res::Resource is the Resource representing electricity. It must be specified explicitly for the proper calculation of the electricity demand for compression.\ndata::Vector{<:Data} is the additional data (e.g., for investments). The field data is conditional through usage of a constructor.\ndischarge_charge::Float64 is the multiplier for specifying the maximum discharge rate relative to the charge rate. A value of 2.0 would imply that it is possible to have double the discharge rate compared to the installed charge capacity.\nlevel_charge::Float64 is the multiplier for specifying the installed storage level capacity relative to the installed storage charge capacity. It is used for checking input data in the case of a generic model and for limiting investments in the case of an AbstractInvestmentModel.\np_min::Float64 is the minimum pressure in the storage.\np_charge::Float64 is the charging pressure into the storage.\np_max::Float64 is the maximum pressure in the storage.\n\nwarning: Units for pressure\nThe unit for the pressure inputs p_min, p_charge, and p_max are not relevant as the isentropic compression is only dependent on the pressure ratio. It is however necessary that all pressures use the same unit, e.g., bar or Pa.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#lib-pub-add","page":"Public","title":"Additional types","text":"","category":"section"},{"location":"library/public/#lib-pub-add-load_limit","page":"Public","title":"Limiting the load","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"The load of a Node can be constrained to an upper and lower bound. This is achieved through the type LoadLimits which incorporates the values for both.","category":"page"},{"location":"library/public/","page":"Public","title":"Public","text":"note: Parametric type\nLoadLimits is a Parametric Composite Type. This implies that the values for min and max have to be of the same type (e.g., both have to be Float or Integer)","category":"page"},{"location":"library/public/","page":"Public","title":"Public","text":"Load limits are incorporated for both electrolyser nodes as well as the reformer node.","category":"page"},{"location":"library/public/","page":"Public","title":"Public","text":"LoadLimits","category":"page"},{"location":"library/public/#EnergyModelsHydrogen.LoadLimits","page":"Public","title":"EnergyModelsHydrogen.LoadLimits","text":"LoadLimits{T<:Real} <: AbstractLoadLimits{T}\n\nType for the incorporation of limits on the capacity utilization of the node through constraining the variable :cap_use.\n\nFields\n\nmin is the minimum load as fraction of the installed capacity.\nmax is the maximum load as fraction of the installed capacity.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#lib-pub-add-unit_commit","page":"Public","title":"Unit commitment","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Unit commitment implies in the context of EMX to parameters that provide information on the stage cost and the minimum time in a stage. They are currently only implemented for the Reformer node, but can be generalized for other node types, if desired.","category":"page"},{"location":"library/public/","page":"Public","title":"Public","text":"CommitParameters","category":"page"},{"location":"library/public/#EnergyModelsHydrogen.CommitParameters","page":"Public","title":"EnergyModelsHydrogen.CommitParameters","text":"struct CommitParameters\n\nType for providing parameters required in unit commitment constraints.\n\nFields\n\nopex::TimeProfile is the cost profile per installed capacity and operational duration if the node is within the state.\ntime::TimeProfile is the minimum time the node has to remain in the state before it can transition to the next state.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#lib-pub-add-ramping","page":"Public","title":"Change of utilization","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Change of utilization constraints, also called ramping constraints, require different types to allow for both constraints on the positive change of utilization (ramp up) and negative change of utilization (ramp down). They are currently only implemented for the Reformer node, but can be generalized for other node types, if desired. In addition, we provide a type when no constraints should be incorporated.","category":"page"},{"location":"library/public/","page":"Public","title":"Public","text":"RampBi\nRampUp\nRampDown\nRampNone","category":"page"},{"location":"library/public/#EnergyModelsHydrogen.RampBi","page":"Public","title":"EnergyModelsHydrogen.RampBi","text":"struct RampBi <: AbstractRampParameters\n\nParameters for both positive and negative ramping constraints for a node.\n\nFields\n\nup::TimeProfile is the maximum positive rate of change of a node.\ndown::TimeProfile is the maximum negative rate of change of a node.\n\nnote: Note\nThe same profile is used for positive and negative bounds if you provide only a single TimeProfile as input.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#EnergyModelsHydrogen.RampUp","page":"Public","title":"EnergyModelsHydrogen.RampUp","text":"struct RampUp <: AbstractRampParameters\n\nParameters for positive ramping constraints for a node.\n\nFields\n\nup::TimeProfile is the maximum positive rate of change of a node.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#EnergyModelsHydrogen.RampDown","page":"Public","title":"EnergyModelsHydrogen.RampDown","text":"struct RampDown <: AbstractRampParameters\n\nParameters for negative ramping constraints for a node.\n\nFields\n\ndown::TimeProfile is the maximum negative rate of change of a node.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#EnergyModelsHydrogen.RampNone","page":"Public","title":"EnergyModelsHydrogen.RampNone","text":"struct RampNone <: AbstractRampParameters\n\nParameters when no ramping constraints should be included.\n\n\n\n\n\n","category":"type"}]
}
